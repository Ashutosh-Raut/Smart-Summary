<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="style.css">
    <!-- down chevron -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- right chevron -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0">
    <!-- sell tag -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- location  -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- email -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- search -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- translate -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@48,400,0,0">

    <!-- calendar -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- play -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- note -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- air -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- plus -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- 3 -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
    <!-- code -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">

    <title>Summary Shala</title>
</head>

<body>

    <nav class="navbar">

        <div class="top-container">

            <ul class="dropdowns">

                <li class="dropdown">
                    <a href="#" class="dropdown-text">University<span class="material-symbols-outlined">expand_more</span></a>
                </li>

                <li class="dropdown">
                    <a href="#" class="dropdown-text">Branch<span class="material-symbols-outlined">expand_more</span></a>
                </li>

            </ul>

            <div id="logo"><a href="index.html"><img src="logo.png" height="55px" width="65px"></a></div>

            <ul class="interactions">
                
                <li class="sign-in"><a href="#" style="padding: 0 20px 0 20px;">Sign In</a></li>
            </ul>
        </div>
    </nav>
    <div class="topic-container">
        <ul class="topics">
            <li><a href="dsa.html">DSA</a></li>
            <li><a href="ai.html">Artificial Intelligence</a></li>
            <li><a href="ml.html">Machine Learning</a></li>
            <li><a href="cc.html">Cloud Computing</a></li>
            <li><a href="se.html">Software Engineering</a></li>
            <li><a href="cn.html">Computer Network</a></li>
            <li><a href="os.html">Operating System</a></li>
            <li><a href="dbs.html">DBMS</a></li>
            <li><a href="oops.html"><div class="footer-link-heading">OOPs</div></a></li>
            <li><a href="daa.html">DAA</a></li>
        </ul>
    </div>

    <main>

        <div class="article-container">

            <div class="sidebar">
                <ul class="sidebar-menu">
                    <li><a href="#unit1">UNIT 1: Introduction to Java Applications</a></li>
                    <li><a href="#unit2">UNIT 2: Control Statements</a></li>
                    <li><a href="#unit3">UNIT 3: Arrays</a></li>
                    <li><a href="#unit4">UNIT 4: Inheritance and Polymorphism in Java</a></li>
                    <li><a href="#unit5">UNIT 5: Exception-handling and Java script</a></li>
                </ul>
            </div>

            <div class="main-content">

                <div id="unit1" class="formatted-text">
                    <!-- Unit 1 text -->
                    <h2>UNIT 1: Introduction to Java Applications</h2>
                    <br>
                    <section>
                        <h3>1.1 Introduction</h3><br>
                        <ol>
                            <li>
                                <strong>What is Java?</strong><br>
                                <ul>
                                    <li>Java is a high-level, class-based, object-oriented programming language designed to be platform-independent (write once, run anywhere).</li><br>
                                    <li>Developed by Sun Microsystems (now Oracle) in 1995.</li><br>
                                    <li>Syntax: Java syntax is similar to C/C++ but has automatic memory management.</li><br>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Key Features of Java:</strong><br>
                                <ul>
                                    <li>Object-Oriented: Java follows the principles of encapsulation, inheritance, and polymorphism.</li><br>
                                    <li>Platform-Independent: Java applications can run on any platform that has a Java Virtual Machine (JVM).</li><br>
                                    <li>Robust: Java has strong exception handling and garbage collection.</li><br>
                                    <li>Secure: Java provides a secure execution environment by using a security manager to restrict applet access to the host system.</li><br>
                                    <li>Multithreading: Java supports concurrent programming through thread creation.</li><br>
                                    <li>Architecture-Neutral: Java programs run on any machine irrespective of its architecture.</li><br>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Java's Evolution:</strong><br>
                                <ul>
                                    <li>Versions: Java has seen several versions since its inception, adding new features and improving performance.</li><br>
                                    <li>Community Support: Java has a large community and a vast ecosystem of libraries and frameworks.</li><br>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Usage of Java:</strong><br>
                                <ul>
                                    <li>Application Development: Java is widely used for web, desktop, and mobile applications.</li><br>
                                    <li>Enterprise Solutions: Java is a preferred choice for building enterprise-level applications due to its robustness and scalability.</li><br>
                                    <li>Embedded Systems: Java is also used in embedded systems, IoT devices, and smart appliances.</li><br>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Getting Started with Java:</strong><br>
                                <ul>
                                    <li>Java SDK: The Java Software Development Kit (SDK) includes the necessary tools for Java development, such as a compiler and libraries.</li><br>
                                    <li>IDE: Integrated Development Environments (IDEs) like Eclipse and IntelliJ IDEA provide advanced development tools.</li><br>
                                    <li>Hello World Example: A simple Java program to print "Hello, World!" to the console.</li><br>
                                </ul>
                            </li>
                        </ol>
                        <br><br>
                    </section>
                    
                    <section>
                        <h3>1.2 Java Class Libraries</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Java Class Libraries are collections of pre-written classes and methods that provide ready-made functionality for Java applications.</li><br>
                                    <li>These libraries form a major part of the Java Development Kit (JDK).</li><br>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Core Java Libraries:</strong><br>
                                <ul>
                                    <li>java.lang: Basic classes for language support (e.g., <code>Object</code>, <code>String</code>, <code>Math</code>).</li><br>
                                    <li>java.util: Utility classes such as collections (<code>List</code>, <code>Set</code>, <code>Map</code>), date and time handling (<code>Date</code>), and random number generation.</li><br>
                                    <li>java.io: Classes for input/output operations, including file and stream handling.</li><br>
                                    <li>java.net: Networking classes for handling URLs, sockets, and network communication.</li><br>
                                    <li>java.awt and javax.swing: Graphical user interface (GUI) components and frameworks.</li><br>
                                    <li>javafx: Modern toolkit for building rich internet applications (RIAs) and GUIs.</li><br>
                                    <li>java.sql: Classes for database connectivity using JDBC (Java Database Connectivity).</li><br>
                                    <li>java.security: Security-related classes for encryption, digital signatures, and certificates.</li><br>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Additional Libraries:</strong><br>
                                <ul>
                                    <li>javax package: Contains classes for enterprise-level development, such as servlet and JSP for web development.</li><br>
                                    <li>javafx package: Offers APIs for modern user interfaces and graphics.</li><br>
                                    <li>org.* packages: Often include additional features like XML parsing and JSON handling.</li><br>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Organization of Class Libraries:</strong><br>
                                <ul>
                                    <li>Libraries are organized into packages, which group related classes together for easy access and logical organization.</li><br>
                                    <li>Classes are further organized into modules starting from Java 9.</li><br>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Usage and Importing Libraries:</strong><br>
                                <ul>
                                    <li>Libraries can be imported into Java applications using the <code>import</code> statement.</li><br>
                                    <li>For example, to use the <code>ArrayList</code> class from the <code>java.util</code> package:</li><br>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Advantages of Java Class Libraries:</strong><br>
                                <ul>
                                    <li>Ease of Development: Pre-written classes and methods save development time.</li><br>
                                    <li>Reusability: Libraries are tested and can be reused across different projects.</li><br>
                                    <li>Consistency: Libraries provide consistent behavior across various Java programs.</li><br>
                                </ul>
                            </li>
                        </ol>
                        <br><br>
                    </section>

                    <section>
                        <h3>1.3 Typical Java Development Environment</h3><br>
                        <ol>
                            <li>
                                <strong>Components of a Java Development Environment:</strong><br>
                                <ul>
                                    <li>Java Development Kit (JDK):<br>
                                        <ul>
                                            <li>Provides necessary tools and libraries for Java development, including the compiler (<code>javac</code>), runtime environment (<code>java</code>), and other utilities (<code>javadoc</code>, <code>jdb</code>, etc.).</li>
                                        </ul>
                                    </li><br>
                                    <li>Java Runtime Environment (JRE):<br>
                                        <ul>
                                            <li>Contains the Java Virtual Machine (JVM), libraries, and other components necessary to run Java applications.</li>
                                        </ul>
                                    </li><br>
                                    <li>Integrated Development Environment (IDE):<br>
                                        <ul>
                                            <li>Software that provides a comprehensive environment for writing, testing, and debugging Java programs (e.g., Eclipse, IntelliJ IDEA, NetBeans).</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Setting Up the Development Environment:</strong><br>
                                <ul>
                                    <li>Installation:<br>
                                        <ul>
                                            <li>Install the JDK from Oracle or OpenJDK website to gain access to Java development tools.</li>
                                        </ul>
                                    </li><br>
                                    <li>Configuring Environment Variables:<br>
                                        <ul>
                                            <li>Add JDK's <code>bin</code> directory to the system path for easy access to tools like <code>javac</code> and <code>java</code> from the command line.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Developing Java Applications:</strong><br>
                                <ul>
                                    <li>Writing Code:<br>
                                        <ul>
                                            <li>Use a text editor or IDE to write Java code.</li>
                                            <li>Java source files have the <code>.java</code> extension.</li>
                                        </ul>
                                    </li><br>
                                    <li>Compiling Code:<br>
                                        <ul>
                                            <li>Use the <code>javac</code> compiler to compile source files into bytecode (<code>.class</code> files).</li>
                                        </ul>
                                    </li><br>
                                    <li>Running Java Applications:<br>
                                        <ul>
                                            <li>Use the <code>java</code> command followed by the class name (without <code>.class</code>) to run a Java program.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Using IDEs for Development:</strong><br>
                                <ul>
                                    <li>Advantages of IDEs:<br>
                                        <ul>
                                            <li>Provides syntax highlighting, code completion, and error checking.</li>
                                            <li>Includes built-in debugging tools, version control integration, and easy project management.</li>
                                        </ul>
                                    </li><br>
                                    <li>Common Java IDEs:<br>
                                        <ul>
                                            <li>Eclipse: A popular, open-source IDE with a wide range of plugins.</li>
                                            <li>IntelliJ IDEA: Known for its intelligent code assistance and efficient development tools.</li>
                                            <li>NetBeans: A comprehensive IDE that supports various languages, including Java.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Debugging and Testing:</strong><br>
                                <ul>
                                    <li>Debugging Tools:<br>
                                        <ul>
                                            <li>IDEs offer built-in debuggers to step through code, inspect variables, and identify issues.</li>
                                        </ul>
                                    </li><br>
                                    <li>Testing Libraries:<br>
                                        <ul>
                                            <li>Frameworks like JUnit provide tools for writing and running unit tests.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                        </ol>
                        <br><br>
                    </section>
                    
                    <section>
                        <h3>1.4 Memory Concepts</h3><br>
                        <ol>
                            <li>
                                <strong>Memory Organization in Java:</strong><br>
                                <ul>
                                    <li>Heap:<br>
                                        <ul>
                                            <li>Area of memory where objects are allocated.</li>
                                            <li>Managed by the Java Virtual Machine (JVM).</li>
                                            <li>Garbage collection automatically reclaims memory by removing objects no longer in use.</li>
                                        </ul>
                                    </li><br>
                                    <li>Stack:<br>
                                        <ul>
                                            <li>Memory region that stores local variables, method parameters, and return addresses.</li>
                                            <li>Each thread has its own stack for execution context.</li>
                                        </ul>
                                    </li><br>
                                    <li>Method Area:<br>
                                        <ul>
                                            <li>Also known as the static memory area.</li>
                                            <li>Contains class-level data such as static variables and method definitions.</li>
                                        </ul>
                                    </li><br>
                                    <li>Program Counter Register:<br>
                                        <ul>
                                            <li>A small memory space that keeps track of the current executing instruction.</li>
                                        </ul>
                                    </li><br>
                                    <li>Native Method Stacks:<br>
                                        <ul>
                                            <li>Memory for native methods, which are not written in Java (e.g., C/C++).</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Key Memory Concepts:</strong><br>
                                <ul>
                                    <li>Variables:<br>
                                        <ul>
                                            <li>Local Variables: Stored in the stack; exist within a method and are discarded after method execution.</li>
                                            <li>Instance Variables: Stored in the heap; part of an object instance.</li>
                                            <li>Static Variables: Stored in the method area; shared across all instances of a class.</li>
                                        </ul>
                                    </li><br>
                                    <li>Memory Allocation:<br>
                                        <ul>
                                            <li>Object Allocation: Objects are allocated in the heap using the <code>new</code> keyword.</li>
                                            <li>Primitive Allocation: Primitives (e.g., <code>int</code>, <code>char</code>) are allocated on the stack.</li>
                                        </ul>
                                    </li><br>
                                    <li>Memory Management:<br>
                                        <ul>
                                            <li>Garbage Collection: Automated process of reclaiming memory from objects no longer in use.</li>
                                        </ul>
                                    </li><br>
                                    <li>Memory Leaks:<br>
                                        <ul>
                                            <li>Occur when objects that are no longer needed are not properly released from memory.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Reference Types and Values:</strong><br>
                                <ul>
                                    <li>Primitive Types:<br>
                                        <ul>
                                            <li>Directly store data values (e.g., <code>int</code>, <code>double</code>).</li>
                                        </ul>
                                    </li><br>
                                    <li>Reference Types:<br>
                                        <ul>
                                            <li>Store references (pointers) to objects in the heap (e.g., <code>String</code>, custom classes).</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Memory Considerations for Java Developers:</strong><br>
                                <ul>
                                    <li>Efficient Object Management:<br>
                                        <ul>
                                            <li>Avoid excessive object creation and reference cycles to prevent memory leaks.</li>
                                        </ul>
                                    </li><br>
                                    <li>Optimize Stack Usage:<br>
                                        <ul>
                                            <li>Recursive methods can lead to stack overflow; be mindful of method call depth.</li>
                                        </ul>
                                    </li><br>
                                    <li>Monitor Memory Usage:<br>
                                        <ul>
                                            <li>Tools like profilers and debuggers can help identify memory bottlenecks and leaks.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Memory Tuning and Profiling:</strong><br>
                                <ul>
                                    <li>JVM Flags:<br>
                                        <ul>
                                            <li>JVM offers various flags for tuning heap and garbage collection settings.</li>
                                        </ul>
                                    </li><br>
                                    <li>Profiling Tools:<br>
                                        <ul>
                                            <li>Use tools such as VisualVM or JProfiler to monitor memory usage and application performance.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                        </ol>
                        <br><br>
                    </section>

                    <section>
                        <h3>1.5 Arithmetic</h3><br>
                        <ol>
                            <li>
                                <strong>Arithmetic Operators:</strong><br>
                                <ul>
                                    <li>Addition (<code>+</code>):<br>
                                        <ul>
                                            <li>Adds two operands.</li>
                                        </ul>
                                    </li><br>
                                    <li>Subtraction (<code>-</code>):<br>
                                        <ul>
                                            <li>Subtracts the right operand from the left operand.</li>
                                        </ul>
                                    </li><br>
                                    <li>Multiplication (<code>*</code>):<br>
                                        <ul>
                                            <li>Multiplies two operands.</li>
                                        </ul>
                                    </li><br>
                                    <li>Division (<code>/</code>):<br>
                                        <ul>
                                            <li>Divides the left operand by the right operand (integer division for integer types).</li>
                                        </ul>
                                    </li><br>
                                    <li>Modulus (<code>%</code>):<br>
                                        <ul>
                                            <li>Returns the remainder of a division operation.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Arithmetic with Different Types:</strong><br>
                                <ul>
                                    <li>Integer Arithmetic:<br>
                                        <ul>
                                            <li>Operations with integer types (<code>int</code>, <code>long</code>) follow integer arithmetic rules.</li>
                                            <li>Integer division discards any fractional part (truncation).</li>
                                        </ul>
                                    </li><br>
                                    <li>Floating-point Arithmetic:<br>
                                        <ul>
                                            <li>Operations with floating-point types (<code>float</code>, <code>double</code>) allow for fractional results.</li>
                                        </ul>
                                    </li><br>
                                    <li>Type Promotion:<br>
                                        <ul>
                                            <li>Arithmetic operations involving different types may promote smaller types to larger types for calculation.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Increment and Decrement Operators:</strong><br>
                                <ul>
                                    <li>Increment (<code>++</code>):<br>
                                        <ul>
                                            <li>Increases the value of a variable by one.</li>
                                        </ul>
                                    </li><br>
                                    <li>Decrement (<code>--</code>):<br>
                                        <ul>
                                            <li>Decreases the value of a variable by one.</li>
                                        </ul>
                                    </li><br>
                                    <li>Prefix vs. Postfix Notation:<br>
                                        <ul>
                                            <li>Prefix (<code>++x</code>, <code>--x</code>) applies the increment/decrement before returning the value.</li>
                                            <li>Postfix (<code>x++</code>, <code>x--</code>) returns the original value before applying the increment/decrement.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Compound Assignment Operators:</strong><br>
                                <ul>
                                    <li>Usage:<br>
                                        <ul>
                                            <li>Combine arithmetic operations with assignment (e.g., <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>).</li>
                                        </ul>
                                    </li><br>
                                    <li>Example:<br>
                                        <ul>
                                            <li><code>x += y;</code> is equivalent to <code>x = x + y;</code>.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Order of Operations (Operator Precedence):</strong><br>
                                <ul>
                                    <li>Hierarchy:<br>
                                        <ul>
                                            <li>Operations follow mathematical precedence: multiplication and division before addition and subtraction.</li>
                                        </ul>
                                    </li><br>
                                    <li>Use of Parentheses:<br>
                                        <ul>
                                            <li>Parentheses can be used to control the order of operations.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Examples:</strong><br>
                                <ul>
                                    <li>Addition Example:<br>
                                        <pre><code>int a = 5;
                    int b = 3;
                    int sum = a + b; // sum is 8
                                        </code></pre>
                                    </li><br>
                                    <li>Floating-point Example:<br>
                                        <pre><code>double x = 5.5;
                    double y = 2.5;
                    double result = x * y; // result is 13.75
                                        </code></pre>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Integer Division and Modulus:</strong><br>
                                <ul>
                                    <li>Integer Division:<br>
                                        <ul>
                                            <li><code>9 / 4</code> results in <code>2</code>, not <code>2.25</code> because it truncates the result.</li>
                                        </ul>
                                    </li><br>
                                    <li>Modulus:<br>
                                        <ul>
                                            <li><code>9 % 4</code> results in <code>1</code> because <code>9</code> divided by <code>4</code> leaves a remainder of <code>1</code>.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                        </ol>
                        <br><br>
                    </section>
                    
                    <section>
                        <h3>1.6 Introduction to Classes and Objects</h3><br>
                        <ol>
                            <li>
                                <strong>Classes and Objects:</strong><br>
                                <ul>
                                    <li><strong>Class:</strong><br>
                                        <ul>
                                            <li>Blueprint or template that defines the structure and behavior of objects.</li>
                                            <li>Contains fields (instance variables) and methods (functions) to operate on the data.</li>
                                        </ul>
                                    </li><br>
                                    <li><strong>Object:</strong><br>
                                        <ul>
                                            <li>Instance of a class that represents a real-world entity.</li>
                                            <li>Objects have state (data) and behavior (methods).</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Creating Classes and Objects:</strong><br>
                                <ul>
                                    <li><strong>Defining a Class:</strong><br>
                                        <ul>
                                            <li>Declare a class using the <code>class</code> keyword.</li>
                                            <li>Include fields (instance variables) and methods within the class body.</li>
                                        </ul>
                                        <pre><code>public class Car {
                        String color;
                        int speed;
                    
                        void accelerate() {
                            speed += 10;
                        }
                    }
                                        </code></pre>
                                    </li><br>
                                    <li><strong>Creating an Object:</strong><br>
                                        <ul>
                                            <li>Use the <code>new</code> keyword to create an instance of a class.</li>
                                        </ul>
                                        <pre><code>Car myCar = new Car();
                                        </code></pre>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Fields and Methods:</strong><br>
                                <ul>
                                    <li><strong>Fields:</strong><br>
                                        <ul>
                                            <li>Variables that hold data for the class.</li>
                                            <li>Also known as instance variables when associated with an object instance.</li>
                                        </ul>
                                    </li><br>
                                    <li><strong>Methods:</strong><br>
                                        <ul>
                                            <li>Functions that define the behavior of an object.</li>
                                            <li>Can modify the state of an object or return values.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Access Modifiers:</strong><br>
                                <ul>
                                    <li><strong>Public:</strong><br>
                                        <ul>
                                            <li>Accessible from any other class.</li>
                                        </ul>
                                    </li><br>
                                    <li><strong>Private:</strong><br>
                                        <ul>
                                            <li>Accessible only within the class where it is defined.</li>
                                        </ul>
                                    </li><br>
                                    <li><strong>Protected:</strong><br>
                                        <ul>
                                            <li>Accessible within the class, subclasses, and the same package.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                        </ol>
                        <br><br>
                    </section>
                    
                    <section>
                        <h3>1.7 Classes</h3><br>
                        <ol >
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li><strong>Class:</strong> A blueprint or template for creating objects. It defines a set of fields (instance variables) and methods (functions) that represent the state and behavior of an object.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Class Declaration:</strong><br>
                                <ul>
                                    <li>Use the <code>class</code> keyword to declare a class, followed by the class name and the class body in curly braces.</li>
                                    <li>A typical class contains fields (variables) and methods (functions).</li>
                                </ul>
                                <pre><code>public class Car {
                        // Fields
                        String color;
                        int speed;
                    
                        // Methods
                        void accelerate() {
                            speed += 10;
                        }
                    
                        void brake() {
                            speed -= 10;
                        }
                    }
                                </code></pre>
                            </li><br>
                            <li>
                                <strong>Access Modifiers:</strong><br>
                                <ul>
                                    <li>Classes and their members (fields and methods) can have access modifiers to control visibility.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Constructor:</strong><br>
                                <ul>
                                    <li>A special method used to initialize objects when they are created.</li>
                                    <li>A class can have multiple constructors (constructor overloading).</li>
                                </ul>
                                <pre><code>public class Car {
                        String color;
                        int speed;
                    
                        // Default constructor
                        public Car() {
                            color = "white";
                            speed = 0;
                        }
                    
                        // Parameterized constructor
                        public Car(String carColor, int carSpeed) {
                            color = carColor;
                            speed = carSpeed;
                        }
                    }
                                </code></pre>
                            </li><br>
                            <li>
                                <strong>Usage Example:</strong><br>
                                <ul>
                                    <li>Creating Objects:</li>
                                </ul>
                                <pre><code>Car myCar = new Car();
                    Car sportsCar = new Car("red", 100);
                                </code></pre>
                            </li><br>
                            <li>
                                <strong>Methods:</strong><br>
                                <ul>
                                    <li>Methods define the behavior of objects and operate on the object's fields.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Static Members:</strong><br>
                                <ul>
                                    <li><strong>Static Fields:</strong> Fields that belong to the class itself, not to any particular instance. Shared across all instances of the class.</li>
                                    <li><strong>Static Methods:</strong> Methods that belong to the class itself, not to any particular instance. Can be called using the class name.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Nested Classes:</strong><br>
                                <ul>
                                    <li><strong>Inner Classes:</strong> Classes defined within another class.</li>
                                    <li><strong>Static Nested Classes:</strong> Nested classes with the <code>static</code> modifier, which behave similarly to regular classes.</li>
                                </ul>
                            </li><br>
                        </ol>
                    </section>
                    
                    <section>
                        <h3>1.8 Objects</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Object: An instance of a class that encapsulates data (fields) and methods (behavior).</li>
                                    <li>Objects represent real-world entities in an application.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Creating Objects:</strong><br>
                                <ul>
                                    <li>Instantiation:<br>
                                        <ul>
                                            <li>Use the <code>new</code> keyword to create an instance of a class.</li>
                                            <li>Memory is allocated on the heap for the object.</li>
                                        </ul>
                                        <pre><code>Car myCar = new Car();</code></pre>
                                    </li><br>
                                    <li>Constructor Invocation:<br>
                                        <ul>
                                            <li>When an object is created, the constructor of the class is called to initialize the object's state.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Accessing Object Members:</strong><br>
                                <ul>
                                    <li>Using the dot operator (<code>.</code>):<br>
                                        <ul>
                                            <li>The dot operator is used to access fields and methods of an object.</li>
                                        </ul>
                                        <pre><code>Car myCar = new Car();
                    myCar.color = "Blue"; // Accessing field
                    myCar.accelerate(); // Calling method</code></pre>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Passing Objects as Arguments:</strong><br>
                                <ul>
                                    <li>Passing by Reference:<br>
                                        <ul>
                                            <li>When an object is passed as an argument to a method, the method receives a reference to the object, not a copy.</li>
                                            <li>Any changes made to the object in the method are reflected in the original object.</li>
                                        </ul>
                                        <pre><code>void paintCar(Car car, String newColor) {
                        car.color = newColor;
                    }
                    
                    Car myCar = new Car();
                    paintCar(myCar, "Red");
                    // myCar.color is now "Red"</code></pre>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Returning Objects from Methods:</strong><br>
                                <ul>
                                    <li>Returning a Reference:<br>
                                        <ul>
                                            <li>Methods can return objects by returning a reference to the object.</li>
                                        </ul>
                                        <pre><code>Car createCar(String color, int speed) {
                        Car newCar = new Car();
                        newCar.color = color;
                        newCar.speed = speed;
                        return newCar;
                    }
                    
                    Car sportsCar = createCar("Yellow", 200);</code></pre>
                                    </li><br>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Object Lifecycle:</strong><br>
                                <ul>
                                    <li>Creation:<br>
                                        <ul>
                                            <li>Objects are created using the <code>new</code> keyword and constructor invocation.</li>
                                        </ul>
                                    </li><br>
                                    <li>Usage:<br>
                                        <ul>
                                            <li>Objects are used by calling their methods and accessing their fields.</li>
                                        </ul>
                                    </li><br>
                                    <li>Destruction:<br>
                                        <ul>
                                            <li>Objects are automatically destroyed by the JVM when they are no longer referenced.</li>
                                        </ul>
                                    </li><br>
                                    <li>Garbage Collection:<br>
                                        <ul>
                                            <li>The JVM automatically reclaims memory of objects no longer in use.</li>
                                        </ul>
                                    </li><br>
                                </ul>
                            </li><br>
                        </ol>
                        <br><br>
                    </section>

                    <section>
                        <h3>1.9.1 Declaring a Class with a Method</h3><br>
                        <ol>
                            <li>
                                <strong>Class Declaration:</strong><br>
                                <ul>
                                    <li>A class is declared using the <code>class</code> keyword followed by the class name and a body enclosed in curly braces.</li>
                                    <li>The class can contain fields (instance variables) and methods (functions).</li>
                                </ul>
                                <pre><code>public class Calculator {
                        // Instance variable
                        int currentResult;
                    
                        // Method to add two numbers
                        public int add(int num1, int num2) {
                            currentResult = num1 + num2;
                            return currentResult;
                        }
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Methods:</strong><br>
                                <ul>
                                    <li>A method is declared with a return type, method name, parameters (optional), and a method body.</li>
                                    <li>In the example above, <code>add</code> is a method that takes two integers as parameters and returns their sum.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Access Modifiers:</strong><br>
                                <ul>
                                    <li>Classes and methods can have access modifiers to control visibility.</li>
                                    <li><code>public</code>: Accessible from anywhere.</li>
                                    <li><code>private</code>: Accessible only within the class.</li>
                                </ul>
                            </li><br>
                        </ol>
                        <br><br>
                    </section>
                    <section>
                        <h3>1.9.2 Instantiating an Object of a Class</h3><br>
                        <ol>
                            <li>
                                <strong>Creating an Object:</strong><br>
                                <ul>
                                    <li>Objects are created (instantiated) using the <code>new</code> keyword followed by the class name and parentheses (to call a constructor).</li>
                                    <li>Memory is allocated on the heap for the object.</li>
                                </ul>
                                <pre><code>Calculator calc = new Calculator();</code></pre>
                            </li><br>
                            <li>
                                <strong>Constructor Invocation:</strong><br>
                                <ul>
                                    <li>When an object is created, the constructor of the class is called to initialize the object's state.</li>
                                    <li>If a class does not define a constructor, the compiler provides a default constructor.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Accessing Methods:</strong><br>
                                <ul>
                                    <li>Once an object is created, its methods can be accessed using the dot operator (<code>.</code>).</li>
                                </ul>
                                <pre><code>int result = calc.add(5, 3); // Calls the add method on the calc object</code></pre>
                            </li><br>
                            <li>
                                <strong>Example:</strong><br>
                                <ul>
                                    <li>Class Declaration:</li>
                                </ul>
                                <pre><code>public class Rectangle {
                        // Instance variables
                        double length;
                        double width;
                    
                        // Constructor
                        public Rectangle(double len, double wid) {
                            length = len;
                            width = wid;
                        }
                    
                        // Method to calculate area
                        public double calculateArea() {
                            return length * width;
                        }
                    }</code></pre>
                                <ul>
                                    <li>Object Instantiation and Method Invocation:</li>
                                </ul>
                                <pre><code>// Instantiate a Rectangle object
                    Rectangle rect = new Rectangle(5.0, 3.0);
                    
                    // Calculate the area using the method
                    double area = rect.calculateArea();
                    System.out.println("Area: " + area); // Output: Area: 15.0</code></pre>
                            </li><br>
                        </ol>
                    </section>
                    
                    <section>
                        <h3>1.10 Declaring a Method</h3><br>
                        <ol>
                            <li>
                                <strong>Method Declaration:</strong><br>
                                <ul>
                                    <li>A method is a function defined within a class that performs a specific action.</li>
                                    <li>Method declaration includes a return type, method name, parameter list (optional), and method body.</li>
                                </ul>
                                <pre><code>public int add(int a, int b) {
                        return a + b;
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Method Components:</strong><br>
                                <ul>
                                    <li><strong>Return Type:</strong> The type of value the method returns. <code>void</code> if the method does not return a value.</li>
                                    <li><strong>Method Name:</strong> Identifier for the method; should be descriptive and follow camelCase naming convention.</li>
                                    <li><strong>Parameters:</strong> Optional list of input arguments the method takes, enclosed in parentheses.</li>
                                    <li><strong>Method Body:</strong> Enclosed in curly braces (<code>{}</code>); contains the code the method executes.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Return Statements:</strong><br>
                                <ul>
                                    <li>If a method has a return type other than <code>void</code>, it must include a <code>return</code> statement.</li>
                                    <li>The <code>return</code> statement must return a value of the specified type.</li>
                                </ul>
                                <pre><code>public int square(int num) {
                        return num * num;
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Method Access Modifiers:</strong><br>
                                <ul>
                                    <li><strong>Public:</strong> Accessible from any class.</li>
                                    <li><strong>Private:</strong> Accessible only within the class where it is defined.</li>
                                    <li><strong>Protected:</strong> Accessible within the same package or by subclasses.</li>
                                    <li><strong>Default (no modifier):</strong> Accessible within the same package.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Method Overloading:</strong><br>
                                <ul>
                                    <li>Multiple methods in a class can have the same name but different parameter lists (number, type, or order of parameters).</li>
                                    <li>Overloading enables methods to perform similar tasks with different inputs.</li>
                                </ul>
                                <pre><code>public int multiply(int a, int b) {
                        return a * b;
                    }
                    
                    public double multiply(double a, double b) {
                        return a * b;
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Method Invocation:</strong><br>
                                <ul>
                                    <li>Methods are called using the dot operator (<code>.</code>) on an object instance.</li>
                                </ul>
                                <pre><code>Calculator calc = new Calculator();
                    int result = calc.add(5, 3); // Calls the add method</code></pre>
                            </li><br>
                            <li>
                                <strong>Static Methods:</strong><br>
                                <ul>
                                    <li><strong>Definition:</strong> Declared with the <code>static</code> keyword.</li>
                                    <li><strong>Usage:</strong> Belong to the class itself, not to any particular object. Can be invoked using the class name.</li>
                                </ul>
                                <pre><code>public static double squareRoot(double number) {
                        return Math.sqrt(number);
                    }
                    
                    // Invocation
                    double result = Math.squareRoot(25);</code></pre>
                            </li><br>
                        </ol>
                    </section>
                    
                    <section>
                        <h3>1.11 Instance Variables</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Instance variables are fields declared within a class but outside any method.</li>
                                    <li>Each object of a class maintains its own copy of instance variables.</li>
                                    <li>Instance variables represent the state of an object.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Declaration and Initialization:</strong><br>
                                <ul>
                                    <li>Declare instance variables using a data type followed by a variable name within a class.</li>
                                    <li>Instance variables can be initialized directly in the declaration or in the constructor.</li>
                                </ul>
                                <pre><code>public class Person {
                        // Instance variables
                        String name;
                        int age;
                    
                        // Constructor
                        public Person(String personName, int personAge) {
                            name = personName;
                            age = personAge;
                        }
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Access Modifiers:</strong><br>
                                <ul>
                                    <li>Instance variables can be controlled by access modifiers to specify their visibility.</li>
                                </ul>
                                <pre><code>public class Car {
                        private String color;
                    
                        // Getter method
                        public String getColor() {
                            return color;
                        }
                    
                        // Setter method
                        public void setColor(String newColor) {
                            color = newColor;
                        }
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Accessing Instance Variables:</strong><br>
                                <ul>
                                    <li>Instance variables can be accessed directly using the dot operator (<code>.</code>) within the class.</li>
                                    <li>From outside the class, it is advisable to use getter and setter methods for controlled access (encapsulation).</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Memory Allocation:</strong><br>
                                <ul>
                                    <li>Instance variables are allocated on the heap along with the object when the object is instantiated using the <code>new</code> keyword.</li>
                                    <li>Each object instance maintains its own distinct copy of the instance variables.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Default Values:</strong><br>
                                <ul>
                                    <li>If instance variables are not initialized, they will be assigned default values.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Usage Example:</strong><br>
                                <p>In the example below, an instance variable <code>name</code> is declared, initialized in the constructor, and accessed using a getter method.</p>
                                <pre><code>public class Student {
                        // Instance variable
                        private String name;
                    
                        // Constructor
                        public Student(String studentName) {
                            name = studentName;
                        }
                    
                        // Getter method
                        public String getName() {
                            return name;
                        }
                    }
                    
                    // Instantiate Student object
                    Student student = new Student("John");
                    System.out.println("Student name: " + student.getName()); // Output: Student name: John</code></pre>
                            </li><br>
                        </ol>
                    </section>

                    <section>
                        <h3>Get Methods</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Also known as getter methods.</li>
                                    <li>Used to retrieve the value of an instance variable from an object.</li>
                                    <li>Typically have a return type matching the type of the instance variable and start with the word "get" followed by the variable name in camelCase.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Purpose:</strong><br>
                                <ul>
                                    <li>Provides controlled access to the instance variables.</li>
                                    <li>Encapsulates the instance variables by allowing only read access from outside the class.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example:</strong><br>
                                <pre><code>public class Person {
                        private String name;
                    
                        // Getter method
                        public String getName() {
                            return name;
                        }
                    }
                    
                    // Usage
                    Person person = new Person();
                    String personName = person.getName(); // Accessing the name instance variable</code></pre>
                            </li><br>
                        </ol>
                    </section>
                    
                    <section>
                        <h3>1.12 Set Methods</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Also known as setter methods.</li>
                                    <li>Used to modify the value of an instance variable in an object.</li>
                                    <li>Typically start with the word "set" followed by the variable name in camelCase and take a parameter of the same type as the instance variable.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Purpose:</strong><br>
                                <ul>
                                    <li>Provides controlled access to instance variables.</li>
                                    <li>Encapsulates the instance variables by allowing only write access from outside the class.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example:</strong><br>
                                <pre><code>public class Person {
                        private String name;
                    
                        // Setter method
                        public void setName(String newName) {
                            name = newName;
                        }
                    }
                    
                    // Usage
                    Person person = new Person();
                    person.setName("Alice"); // Modifying the name instance variable</code></pre>
                            </li><br>
                            <li>
                                <strong>Benefits of Getters and Setters:</strong><br>
                                <ul>
                                    <li>Encapsulation: Allows hiding the implementation details of instance variables and provides controlled access.</li>
                                    <li>Data Validation: Set methods can include validation checks before modifying the instance variables.</li>
                                    <li>Data Consistency: Methods can ensure consistent data state and behavior when modifying variables.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example Usage with Data Validation:</strong><br>
                                <pre><code>public class BankAccount {
                        private double balance;
                    
                        // Getter method
                        public double getBalance() {
                            return balance;
                        }
                    
                        // Setter method with data validation
                        public void setBalance(double amount) {
                            if (amount >= 0) {
                                balance = amount;
                            } else {
                                System.out.println("Balance cannot be negative");
                            }
                        }
                    }
                    
                    // Usage
                    BankAccount account = new BankAccount();
                    account.setBalance(1000.0); // Sets balance to 1000.0
                    double currentBalance = account.getBalance(); // Accesses the current balance</code></pre>
                            </li><br>
                        </ol>
                    </section>
                    
                    <section>
                        <h3>1.13.1 Primitive Types</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Built-in data types in Java that represent basic values.</li>
                                    <li>They are not objects and do not have methods.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Types:</strong><br>
                                <ul>
                                    <li>There are eight primitive data types in Java:</li>
                                    <ul>
                                        <li><code>byte</code> (8-bit integer)</li>
                                        <li><code>short</code> (16-bit integer)</li>
                                        <li><code>int</code> (32-bit integer)</li>
                                        <li><code>long</code> (64-bit integer)</li>
                                        <li><code>float</code> (32-bit floating-point)</li>
                                        <li><code>double</code> (64-bit floating-point)</li>
                                        <li><code>char</code> (16-bit Unicode character)</li>
                                        <li><code>boolean</code> (true or false)</li>
                                    </ul>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Characteristics:</strong><br>
                                <ul>
                                    <li>Stored directly in memory.</li>
                                    <li>Passed by value: When a primitive is passed to a method, a copy is made.</li>
                                    <li>Have default values (<code>0</code> for numeric types, <code>false</code> for boolean, and <code>'\u0000'</code> for char).</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example:</strong><br>
                                <pre><code>int num = 5;
                    boolean isTrue = true;</code></pre>
                            </li><br>
                        </ol>
                    </section>
                    
                    <section>
                        <h3>1.13.2 Reference Types</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Data types that refer to objects.</li>
                                    <li>Include arrays, classes, interfaces, and enumerations.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Characteristics:</strong><br>
                                <ul>
                                    <li>Reference types hold the memory address (reference) of the actual data.</li>
                                    <li>Passed by reference: When a reference type is passed to a method, the reference (memory address) is passed, not a copy.</li>
                                    <li>Have a default value of <code>null</code>.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Examples:</strong><br>
                                <ul>
                                    <li>Class: <code>String str = new String("Hello");</code></li>
                                    <li>Array: <code>int[] numbers = new int[5];</code></li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>String Reference Type:</strong><br>
                                <ul>
                                    <li><code>String</code> is a special reference type representing sequences of characters.</li>
                                    <li>Strings are immutable, meaning they cannot be changed after creation.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Common Reference Types in Java:</strong><br>
                                <ul>
                                    <li>Class: A blueprint for creating objects.</li>
                                    <li>Array: A data structure that holds a fixed-size collection of elements of the same type.</li>
                                    <li>Interface: Defines methods that a class must implement.</li>
                                    <li>Enumeration: A special class representing a group of named constants.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Memory Allocation:</strong><br>
                                <ul>
                                    <li>Reference types are allocated in the heap, and the references are stored in variables.</li>
                                    <li>Multiple references can point to the same object.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example Usage:</strong><br>
                                <pre><code>// Passing by value
                    void increment(int x) {
                        x++;
                    }
                    int num = 5;
                    increment(num);
                    // num is still 5
                    
                    // Passing by reference
                    void modifyArray(int[] arr) {
                        arr[0] = 10;
                    }
                    int[] numbers = {1, 2, 3};
                    modifyArray(numbers);
                    // numbers[0] is now 10</code></pre>
                            </li><br>
                        </ol>
                    </section>
                    
                    <section>
                        <h3>1.14 Initializing Objects with Constructors</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>A constructor is a special method in a class that is called when an object is created.</li>
                                    <li>Its purpose is to initialize the object's state (instance variables).</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Constructor Declaration:</strong><br>
                                <ul>
                                    <li>A constructor has the same name as the class and does not have a return type (not even <code>void</code>).</li>
                                    <li>It can take parameters to initialize the instance variables.</li>
                                </ul>
                                <pre><code>public class Person {
                        // Instance variables
                        String name;
                        int age;
                    
                        // Constructor
                        public Person(String personName, int personAge) {
                            name = personName;
                            age = personAge;
                        }
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Types of Constructors:</strong><br>
                                <ul>
                                    <li><strong>Default Constructor:</strong></li>
                                    <ul>
                                        <li>A no-argument constructor that initializes instance variables to their default values.</li>
                                        <li>Automatically provided by the compiler if no constructor is defined in the class.</li>
                                    </ul>
                                    <li><strong>Parameterized Constructor:</strong></li>
                                    <ul>
                                        <li>A constructor that takes parameters to initialize the object's state.</li>
                                    </ul>
                                </ul>
                                <pre><code>// Default constructor
                    public class Car {
                        private String color;
                    
                        // Constructor
                        public Car() {
                            color = "white";
                        }
                    }
                    
                    // Parameterized constructor
                    public class Car {
                        private String color;
                    
                        // Constructor
                        public Car(String carColor) {
                            color = carColor;
                        }
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Constructor Overloading:</strong><br>
                                <ul>
                                    <li>Multiple constructors can be defined in a class, each with different parameters.</li>
                                    <li>This allows objects to be initialized in different ways based on the constructor used.</li>
                                </ul>
                                <pre><code>public class Book {
                        String title;
                        String author;
                    
                        // Default constructor
                        public Book() {
                            title = "Unknown";
                            author = "Unknown";
                        }
                    
                        // Parameterized constructor
                        public Book(String bookTitle, String bookAuthor) {
                            title = bookTitle;
                            author = bookAuthor;
                        }
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Constructor Invocation:</strong><br>
                                <ul>
                                    <li>Constructors are called when an object is instantiated using the <code>new</code> keyword.</li>
                                </ul>
                                <pre><code>// Using parameterized constructor
                    Person person = new Person("Alice", 25);
                    
                    // Using default constructor
                    Car myCar = new Car();</code></pre>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Initialize all instance variables within the constructor.</li>
                                    <li>Keep constructor logic simple and avoid performing complex operations.</li>
                                    <li>Use constructor overloading to allow flexibility in object initialization.</li>
                                </ul>
                            </li><br>
                        </ol>
                    </section>
                    
                    <section>
                        <h3>1.15 Floating Point Numbers</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Floating point numbers represent real numbers that contain a fractional part (decimal point).</li>
                                    <li>Java provides two types of floating point numbers: <code>float</code> and <code>double</code>.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Data Types:</strong><br>
                                <ul>
                                    <li><code>float</code>:</li>
                                    <ul>
                                        <li>32-bit single-precision floating point number.</li>
                                        <li>Can represent approximately 7 decimal digits of precision.</li>
                                        <li>Suffix <code>f</code> or <code>F</code> is used for literals.</li>
                                    </ul>
                                    <li><code>double</code>:</li>
                                    <ul>
                                        <li>64-bit double-precision floating point number.</li>
                                        <li>Can represent approximately 15 decimal digits of precision.</li>
                                        <li>Suffix <code>d</code> or <code>D</code> can be used for literals (optional).</li>
                                    </ul>
                                </ul>
                                <pre><code>float floatNum = 3.14f;
                    double doubleNum = 3.14;</code></pre>
                            </li><br>
                            <li>
                                <strong>Precision and Range:</strong><br>
                                <ul>
                                    <li><code>float</code>:</li>
                                    <ul>
                                        <li>Range: Approximately ±3.4 x 10^38.</li>
                                    </ul>
                                    <li><code>double</code>:</li>
                                    <ul>
                                        <li>Range: Approximately ±1.7 x 10^308.</li>
                                    </ul>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Usage:</strong><br>
                                <ul>
                                    <li><code>float</code>:</li>
                                    <ul>
                                        <li>Used when memory space is a consideration and less precision is acceptable.</li>
                                    </ul>
                                    <li><code>double</code>:</li>
                                    <ul>
                                        <li>Preferred for calculations requiring higher precision.</li>
                                    </ul>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Floating Point Operations:</strong><br>
                                <ul>
                                    <li>Floating point operations may introduce rounding errors due to the binary representation of real numbers.</li>
                                    <li>Use <code>double</code> instead of <code>float</code> for more precise calculations.</li>
                                    <li>Compare floating point numbers using an epsilon value for precision.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Type Casting:</strong><br>
                                <ul>
                                    <li>Casting between <code>float</code> and <code>double</code> is possible:</li>
                                    <ul>
                                        <li><code>double</code> to <code>float</code>:</li>
                                        <pre><code>double d = 3.14;
                    float f = (float) d;</code></pre>
                                        <li><code>float</code> to <code>double</code>:</li>
                                        <pre><code>float f = 3.14f;
                    double d = f;</code></pre>
                                    </ul>
                                </ul>
                            </li><br>
                        </ol>
                    </section>
                    
                </div>

                <div id="unit2" class="formatted-text">
                    <!-- Unit 2 text -->
                    <h2>UNIT 2: Control Statements</h2>
                    <br>
                    <section>
                        <h3>Control Structures</h3><br>
                        <p>Control structures allow the control of the flow of execution in a program. Types of control structures include selection statements and iteration statements.</p><br>
                        <ol>
                            <li>
                                <h3>If Single-Selection Statement</h3>
                                <p>Executes a block of code based on a condition.</p>
                                <pre><code>int num = 5;
                    if (num > 0) {
                        System.out.println("Positive number");
                    }</code></pre>
                            </li><br>
                            <li>
                                <h3>If...Else Double-Selection Statement</h3>
                                <p>Executes one block of code if a condition is true, otherwise executes another block.</p>
                                <pre><code>int num = 5;
                    if (num > 0) {
                        System.out.println("Positive number");
                    } else {
                        System.out.println("Negative number or zero");
                    }</code></pre>
                            </li><br>
                            <li>
                                <h3>While Repetition Statement</h3>
                                <p>Executes a block of code repeatedly while a condition is true.</p>
                                <pre><code>int count = 0;
                    while (count < 5) {
                        System.out.println("Count: " + count);
                        count++;
                    }</code></pre>
                            </li><br>
                            <li>
                                <h3>Do...While Repetition Statement</h3>
                                <p>Similar to <code>while</code> but guarantees at least one iteration as the condition is checked after executing the block.</p>
                                <pre><code>int count = 0;
                    do {
                        System.out.println("Count: " + count);
                        count++;
                    } while (count < 5);</code></pre>
                            </li><br>
                            <li>
                                <h3>Switch Multi-Selection Statement</h3>
                                <p>Allows selection from multiple options based on an expression. Typically used with integer or character expressions.</p>
                                <pre><code>int day = 3;
                    switch (day) {
                        case 1:
                            System.out.println("Monday");
                            break;
                        case 2:
                            System.out.println("Tuesday");
                            break;
                        case 3:
                            System.out.println("Wednesday");
                            break;
                        default:
                            System.out.println("Invalid day");
                    }</code></pre>
                            </li><br>
                            <li>
                                <h3>Break and Continue Statements</h3>
                                <p><strong>Break Statement:</strong> Exits the loop or switch statement immediately.</p>
                                <pre><code>for (int i = 0; i < 5; i++) {
                        if (i == 3) {
                            break; // Exits the loop
                        }
                        System.out.println(i);
                    }</code></pre>
                                <p><strong>Continue Statement:</strong> Skips the current iteration and proceeds to the next iteration.</p>
                                <pre><code>for (int i = 0; i < 5; i++) {
                        if (i == 3) {
                            continue; // Skip the current iteration
                        }
                        System.out.println(i);
                    }</code></pre>
                            </li><br>
                        </ol>
                    </section>

                    <section>
                        <h3>7. Logical Operators</h3><br>
                        <ul>
                            <li>Logical AND (<code>&amp;&amp;</code>):</li>
                            <ul>
                                <li>True only if both operands are true.</li>
                            </ul>
                            <li>Logical OR (<code>||</code>):</li>
                            <ul>
                                <li>True if either operand is true.</li>
                            </ul>
                            <li>Logical NOT (<code>!</code>):</li>
                            <ul>
                                <li>Inverts the truth value of the operand.</li>
                            </ul>
                        </ul>
                    </section><br>
                    <section>
                        <h3>8. Methods</h3><br>
                        <h4>Introduction</h4>
                        <ol>
                            <li>
                                <strong>Introduction:</strong><br>
                                <ul>
                                    <li>Methods are blocks of code that perform specific tasks.</li>
                                    <li>They can take arguments and return a value.</li>
                                    <li>Methods are defined within a class and operate on the class's instance variables.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Declaration:</strong><br>
                                <ul>
                                    <li>Methods have a return type, method name, parameter list (optional), and method body.</li>
                                </ul>
                                <pre><code>public int add(int a, int b) {
                        return a + b;
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Return Types:</strong><br>
                                <ul>
                                    <li>Methods can return a value of a specific type or have a <code>void</code> return type if they do not return anything.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Parameters:</strong><br>
                                <ul>
                                    <li>Methods can take parameters, which are input values that the method can use during execution.</li>
                                    <li>Parameters are defined in the method declaration and passed when calling the method.</li>
                                </ul>
                                <pre><code>public void printMessage(String message) {
                        System.out.println(message);
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Method Invocation:</strong><br>
                                <ul>
                                    <li>Methods are called using the dot operator (<code>.</code>) on an object instance.</li>
                                </ul>
                                <pre><code>Calculator calc = new Calculator();
                    int result = calc.add(5, 3); // Calling the add method</code></pre>
                            </li><br>
                            <li>
                                <strong>Method Overloading:</strong><br>
                                <ul>
                                    <li>Multiple methods can have the same name but different parameter lists, enabling different versions of a method to handle different types of input.</li>
                                </ul>
                                <pre><code>public int multiply(int a, int b) {
                        return a * b;
                    }
                    
                    public double multiply(double a, double b) {
                        return a * b;
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Scope of Declaration:</strong><br>
                                <ul>
                                    <li>Variables declared within a method have local scope and are accessible only within that method.</li>
                                    <li>Instance variables can be accessed by any method in the class.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Recursion:</strong><br>
                                <ul>
                                    <li>Methods can call themselves, known as recursion.</li>
                                    <li>Recursion should have a base case to prevent infinite recursion.</li>
                                </ul>
                                <pre><code>public int factorial(int n) {
                        if (n == 0) {
                            return 1; // Base case
                        }
                        return n * factorial(n - 1); // Recursive call
                    }</code></pre>
                            </li><br>
                            <li>
                                <strong>Examples:</strong><br>
                                <ul>
                                    <li><strong>Addition Method:</strong></li>
                                </ul>
                                <pre><code>public class Calculator {
                        public int add(int a, int b) {
                            return a + b;
                        }
                    }</code></pre>
                                <ul>
                                    <li><strong>Calling a Method:</strong></li>
                                </ul>
                                <pre><code>Calculator calc = new Calculator();
                    int result = calc.add(3, 2); // Result is 5</code></pre>
                            </li><br>
                        </ol>
                    </section>
                    
                    <section>
                        <h3>9. Program Modules in Java</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>A program module in Java typically refers to a section of code designed to perform a specific function.</li>
                                    <li>Java organizes code into classes and methods (functions) to improve modularity and readability.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Benefits of Modularization:</strong><br>
                                <ul>
                                    <li><strong>Reusability:</strong> Code can be reused across different parts of the program or in different projects.</li>
                                    <li><strong>Maintainability:</strong> Code is easier to maintain when it is organized into logical modules.</li>
                                    <li><strong>Abstraction:</strong> Complex functionality can be hidden behind simple interfaces.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Components of Program Modules:</strong><br>
                                <ul>
                                    <li><strong>Classes:</strong> Define the blueprint for creating objects. Contain methods and variables.</li>
                                    <li><strong>Methods:</strong> Define actions that objects can perform. Can take parameters and return values.</li>
                                    <li><strong>Packages:</strong> Group classes and interfaces into namespaces, providing better organization and avoiding naming conflicts.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Modularity and Access Control:</strong><br>
                                <ul>
                                    <li>Use access modifiers (<code>public</code>, <code>protected</code>, and <code>private</code>) to control access to classes, methods, and variables.</li>
                                    <li>Proper access control improves encapsulation and protects the integrity of data.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Example of Program Modules:</strong><br>
                                <pre><code>// This is a module named Calculator
                    public class Calculator {
                        // Method to add two numbers
                        public int add(int a, int b) {
                            return a + b;
                        }
                        
                        // Method to subtract two numbers
                        public int subtract(int a, int b) {
                            return a - b;
                        }
                    }</code></pre>
                            </li>
                            <br>
                            <li>
                                <strong>Importing Modules:</strong><br>
                                <pre><code>import java.util.ArrayList; // Importing ArrayList from java.util package</code></pre>
                            </li>
                            <br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Organize code into classes and packages: Improves code structure and readability.</li>
                                    <li>Follow naming conventions: Use proper naming conventions for packages, classes, and methods.</li>
                                    <li>Limit the scope of variables and methods: Declare variables and methods at the appropriate level of access control (e.g., private, protected, public) based on usage needs.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Main Method as a Module:</strong><br>
                                <ul>
                                    <li>The <code>main</code> method is the entry point of a Java program and can be considered a module itself.</li>
                                    <li>It can call other methods and create objects as needed.</li>
                                </ul>
                            </li>
                        </ol>
                        <br>
                    </section>
                    
                    <section>
                        <h3>10. Static Methods</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Static methods are methods that belong to the class itself rather than to any particular object instance.</li>
                                    <li>Declared with the <code>static</code> keyword.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Characteristics:</strong><br>
                                <ul>
                                    <li>Can be called using the class name, without creating an object.</li>
                                    <li>Cannot access or modify instance variables directly.</li>
                                    <li>Cannot use <code>this</code> or <code>super</code> keywords.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Usage:</strong><br>
                                <ul>
                                    <li>Commonly used for utility functions, mathematical operations, or methods that do not rely on object state.</li>
                                    <li>Often used in combination with static fields (class variables).</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Declaration:</strong><br>
                                <pre><code>public class Calculator {
                        // Static method
                        public static int add(int a, int b) {
                            return a + b;
                        }
                    }</code></pre>
                            </li>
                            <br>
                            <li>
                                <strong>Invocation:</strong><br>
                                <pre><code>int sum = Calculator.add(5, 3); // Invoking the add method</code></pre>
                            </li>
                            <br>
                            <li>
                                <strong>Static Methods and Access Control:</strong><br>
                                <ul>
                                    <li>Static methods can have access modifiers (<code>public</code>, <code>private</code>, <code>protected</code>) just like other methods.</li>
                                    <li>Public static methods can be accessed from anywhere in the program using the class name.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Static Methods in Interfaces:</strong><br>
                                <ul>
                                    <li>Java interfaces can contain static methods starting from Java 8.</li>
                                    <li>These methods provide functionality related to the interface, but they are not inherited by implementing classes.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Examples:</strong><br>
                                <ul>
                                    <li><strong>Math Class:</strong> Java provides a <code>Math</code> class with many static methods for mathematical operations.
                                        <pre><code>double result = Math.sqrt(16); // Calls static method sqrt</code></pre>
                                    </li>
                                    <li><strong>Utility Class:</strong> Static methods are commonly used in utility classes for functions that don't require instance variables.
                                        <pre><code>public class MathUtils {
                        // Static method for square root
                        public static double sqrt(double number) {
                            return Math.sqrt(number);
                        }
                    }
                    
                    double result = MathUtils.sqrt(25);</code></pre>
                                    </li>
                                </ul>
                            </li>
                        </ol><br>
                    </section>
                    
                    <section>
                        <h3>11. Static Fields and Class Math</h3><br>
                        <ol>
                            <li>
                                <strong>Static Fields</strong><br>
                                <ul>
                                    <li>
                                        <strong>Definition:</strong><br>
                                        <ul>
                                            <li>Also known as class variables.</li>
                                            <li>Shared among all instances of a class.</li>
                                            <li>Declared with the <code>static</code> keyword within a class.</li>
                                        </ul>
                                    </li>
                                    <br>
                                    <li>
                                        <strong>Characteristics:</strong><br>
                                        <ul>
                                            <li>Static fields are allocated memory only once, regardless of the number of objects created.</li>
                                            <li>They are shared across all instances of a class and can be accessed using the class name or an instance of the class.</li>
                                            <li>Typically used for constants or values that need to be shared among all objects.</li>
                                        </ul>
                                    </li>
                                    <br>
                                    <li>
                                        <strong>Declaration and Access:</strong><br>
                                        <pre><code>public class Calculator {
                        // Static field
                        public static final double PI = 3.14159;
                    
                        public static void main(String[] args) {
                            // Accessing static field using class name
                            System.out.println(Calculator.PI);
                        }
                    }</code></pre>
                                    </li>
                                </ul>
                            </li>
                        </ol><br>
                        <li>
                            <strong>Class Math</strong><br>
                            <ul>
                                <li>
                                    <strong>Overview:</strong><br>
                                    <ul>
                                        <li>The <code>Math</code> class in Java provides methods and constants for performing mathematical operations.</li>
                                    </ul>
                                </li>
                                <br>
                                <li>
                                    <strong>Common Constants:</strong><br>
                                    <ul>
                                        <li><code>Math.PI</code>: The value of pi (π), approximately 3.14159.</li>
                                        <li><code>Math.E</code>: The base of natural logarithms (e), approximately 2.71828.</li>
                                    </ul>
                                </li>
                                <br>
                                <li>
                                    <strong>Common Methods:</strong><br>
                                    <ul>
                                        <li><code>Math.sqrt(double a)</code>: Returns the square root of a number.</li>
                                        <li><code>Math.pow(double a, double b)</code>: Returns a raised to the power of b (<code>a^b</code>).</li>
                                        <li><code>Math.abs(double a)</code>: Returns the absolute value of a number.</li>
                                        <li><code>Math.round(double a)</code>: Rounds a double to the nearest integer.</li>
                                        <li><code>Math.sin(double a)</code>: Returns the sine of an angle in radians.</li>
                                        <li><code>Math.cos(double a)</code>: Returns the cosine of an angle in radians.</li>
                                    </ul>
                                </li>
                                <br>
                                <li>
                                    <strong>Example Usage:</strong><br>
                                    <pre><code>// Using Math class methods
                    double squareRoot = Math.sqrt(16);
                    double power = Math.pow(2, 3); // 2^3 = 8
                    double absoluteValue = Math.abs(-10); // 10
                    
                    // Using Math class constants
                    double circumference = 2 * Math.PI * 5; // Circumference of a circle with radius 5
                    </code></pre>
                                </li>
                            </ul>
                        </li><br>
                    </section>
                    
                    <section>
                        <h3>12. Declaring Methods with Multiple Parameters</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>A method can take multiple parameters, allowing it to operate on different data or perform more complex tasks.</li>
                                    <li>Parameters are listed within the method declaration, separated by commas.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Method Declaration:</strong><br>
                                <ul>
                                    <li>A method's parameter list includes multiple parameters, each with a specified data type and name.</li>
                                    <li>Parameters are separated by commas within the parentheses.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Example:</strong><br>
                                <ul>
                                    <li>Declaring a method with multiple parameters:</li>
                                </ul>
                                <pre><code>public void printInfo(String name, int age) {
                        System.out.println("Name: " + name + ", Age: " + age);
                    }</code></pre>
                            </li>
                            <br>
                            <li>
                                <strong>Passing Parameters:</strong><br>
                                <ul>
                                    <li>When calling a method with multiple parameters, the arguments must match the data types and order of the method parameters.</li>
                                </ul>
                                <pre><code>printInfo("Alice", 25); // Correct usage</code></pre>
                            </li>
                            <br>
                            <li>
                                <strong>Method Invocation:</strong><br>
                                <ul>
                                    <li>When invoking a method, pass the arguments in the order specified in the method declaration.</li>
                                </ul>
                                <pre><code>public class Calculator {
                        // Method with multiple parameters
                        public int multiply(int a, int b) {
                            return a * b;
                        }
                    }
                    
                    // Usage
                    Calculator calc = new Calculator();
                    int product = calc.multiply(3, 4); // product is 12</code></pre>
                            </li>
                            <br>
                            <li>
                                <strong>Method Overloading:</strong><br>
                                <ul>
                                    <li>Multiple methods can be defined with the same name but different parameter lists (different number, type, or order of parameters).</li>
                                    <li>Overloading allows methods to perform similar tasks with different inputs.</li>
                                </ul>
                                <pre><code>public class MathUtils {
                        // Method to multiply two integers
                        public int multiply(int a, int b) {
                            return a * b;
                        }
                    
                        // Method to multiply three integers
                        public int multiply(int a, int b, int c) {
                            return a * b * c;
                        }
                    }</code></pre>
                            </li>
                            <br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Limit the number of parameters in a method for better readability and maintainability.</li>
                                    <li>If a method requires too many parameters, consider using an object to encapsulate the data.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Example Usage:</strong><br>
                                <ul>
                                    <li>Using a method with multiple parameters:</li>
                                </ul>
                                <pre><code>public class Person {
                        public void displayInfo(String name, int age, String address) {
                            System.out.println("Name: " + name);
                            System.out.println("Age: " + age);
                            System.out.println("Address: " + address);
                        }
                    }
                    
                    Person person = new Person();
                    person.displayInfo("John", 30, "123 Main St");</code></pre>
                            </li>
                        </ol>
                    </section>

                    <section>
                        <h3>13. Scope of Declaration</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>The scope of declaration refers to the context in which a variable or method is declared and accessible.</li>
                                    <li>Determines where a variable or method can be used and where it is out of scope.</li>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Types of Scope:</strong><br>
                                <ul>
                                    <li><strong>Local Scope:</strong></li>
                                    <ul>
                                        <li>Variables declared within a method, loop, or block.</li>
                                        <li>Accessible only within the specific block of code where declared.</li>
                                    </ul>
                                    <li><strong>Instance Scope:</strong></li>
                                    <ul>
                                        <li>Instance variables (fields) are accessible within any method in the class.</li>
                                        <li>Exist for the lifetime of the object.</li>
                                    </ul>
                                    <li><strong>Class Scope:</strong></li>
                                    <ul>
                                        <li>Class variables (static fields) and methods (static methods) are accessible throughout the class.</li>
                                        <li>Shared across all instances of the class.</li>
                                    </ul>
                                    <li><strong>Package Scope:</strong></li>
                                    <ul>
                                        <li>Also known as default scope.</li>
                                        <li>No explicit access modifier (public, private, protected) means the variable or method is accessible within the same package.</li>
                                    </ul>
                                    <li><strong>Global Scope:</strong></li>
                                    <ul>
                                        <li>Refers to static variables and methods accessible across different classes and packages.</li>
                                    </ul>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Examples of Scope:</strong><br>
                                <ul>
                                    <li><strong>Local Scope:</strong></li>
                                    <pre><code>public void printMessage() {
                        int localVar = 5; // Local variable
                        System.out.println(localVar); // Accessible within the method
                    }</code></pre>
                                    <li><strong>Instance Scope:</strong></li>
                                    <pre><code>public class Car {
                        // Instance variable
                        private String color;
                        
                        public void setColor(String newColor) {
                            color = newColor; // Accessible within the class
                        }
                    }</code></pre>
                                    <li><strong>Class Scope:</strong></li>
                                    <pre><code>public class Calculator {
                        // Static field (class variable)
                        public static final double PI = 3.14159;
                        
                        // Static method
                        public static int add(int a, int b) {
                            return a + b;
                        }
                    }</code></pre>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Shadowing:</strong><br>
                                <ul>
                                    <li>A local variable can have the same name as an instance variable, in which case the local variable "shadows" the instance variable.</li>
                                    <li>Access instance variables using the <code>this</code> keyword to avoid confusion.</li>
                                </ul>
                                <pre><code>public class Person {
                        private String name; // Instance variable
                        
                        public void setName(String name) {
                            this.name = name; // Using 'this' to access instance variable
                        }
                    }</code></pre>
                            </li>
                            <br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Use local variables where appropriate to keep variable scope limited.</li>
                                    <li>Choose meaningful variable names to avoid shadowing and improve code readability.</li>
                                    <li>Avoid excessive use of global variables to maintain encapsulation.</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <br>
                    <section>
                        <h3>14. Method Overloading and Java API Packages</h3><br>
                        <ol>
                            <li>
                                <strong>Method Overloading</strong><br>
                                <ul>
                                    <li><strong>Definition:</strong></li>
                                    <ul>
                                        <li>Method overloading allows multiple methods in a class to have the same name but different parameter lists (different number, type, or order of parameters).</li>
                                        <li>The method called is determined by the number, types, and order of arguments passed.</li>
                                    </ul>
                                    <br>
                                    <li><strong>Benefits:</strong></li>
                                    <ul>
                                        <li>Provides flexibility in handling different input scenarios.</li>
                                        <li>Improves code readability and usability by using the same method name for similar operations.</li>
                                    </ul>
                                    <br>
                                    <li><strong>Examples:</strong></li>
                                    <ul>
                                        <li><strong>Simple Overloading:</strong></li>
                                        <pre><code>public class Calculator {
                        // Overloaded methods
                        public int add(int a, int b) {
                            return a + b;
                        }
                    
                        public double add(double a, double b) {
                            return a + b;
                        }
                    }</code></pre>
                                        <li><strong>Method Selection:</strong></li>
                                        <ul>
                                            <li>When a method is called, the compiler selects the appropriate method based on the argument types and number.</li>
                                        </ul>
                                        <pre><code>Calculator calc = new Calculator();
                    int sumInt = calc.add(3, 4); // Calls int add method
                    double sumDouble = calc.add(3.5, 4.5); // Calls double add method</code></pre>
                                    </ul>
                                    <br>
                                    <li><strong>Method Signatures:</strong></li>
                                    <ul>
                                        <li>Method overloading relies on different method signatures.</li>
                                        <li>A method signature includes the method name and parameter list (types and order).</li>
                                    </ul>
                                    <br>
                                    <li><strong>Overloading Best Practices:</strong></li>
                                    <ul>
                                        <li>Use meaningful method names and parameters for clarity.</li>
                                        <li>Avoid excessive overloading, which can make code difficult to understand.</li>
                                    </ul>
                                </ul>
                            </li>
                            <br>
                            <li>
                                <strong>Java API Packages</strong><br>
                                <ul>
                                    <li><strong>Definition:</strong></li>
                                    <ul>
                                        <li>Java provides a set of standard API packages that offer ready-to-use classes and interfaces for various purposes.</li>
                                    </ul>
                                    <br>
                                    <li><strong>Common Java API Packages:</strong></li>
                                    <ul>
                                        <li><code>java.lang</code>: Core language features such as <code>Object</code>, <code>String</code>, <code>Math</code>, and <code>System</code> classes.</li>
                                        <li><code>java.util</code>: Utility classes like collections (<code>List</code>, <code>Set</code>, <code>Map</code>), date and time handling, and random number generation.</li>
                                        <li><code>java.io</code>: Input/output operations, file handling, and stream classes.</li>
                                        <li><code>java.net</code>: Networking classes for handling URLs, sockets, and network communication.</li>
                                        <li><code>java.sql</code>: Database connectivity using JDBC (Java Database Connectivity).</li>
                                        <li><code>java.awt</code> and <code>javax.swing</code>: GUI components and frameworks for graphical user interface development.</li>
                                    </ul>
                                    <br>
                                    <li><strong>Importing Java API Packages:</strong></li>
                                    <ul>
                                        <li>Use <code>import</code> statements to access classes and interfaces from Java API packages.</li>
                                    </ul>
                                    <pre><code>import java.util.ArrayList; // Importing ArrayList from java.util package</code></pre>
                                    <br>
                                    <li><strong>Examples of Java API Usage:</strong></li>
                                    <ul>
                                        <li><code>java.util</code> Package:</li>
                                        <pre><code>import java.util.ArrayList;
                    
                    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
                    list.add("Hello");
                    list.add("World");</code></pre>
                                        <li><code>java.io</code> Package:</li>
                                        <pre><code>import java.io.BufferedReader;
                    import java.io.FileReader;
                    
                    try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
                        String line;
                        while ((line = reader.readLine()) != null) {
                            System.out.println(line);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }</code></pre>
                                    </ul>
                                    <br>
                                    <li><strong>Best Practices:</strong></li>
                                    <ul>
                                        <li>Use Java API packages to avoid reinventing the wheel.</li>
                                        <li>Refer to the official Java documentation for detailed usage and examples.</li>
                                    </ul>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    
                </div>

                <div id="unit3" class="formatted-text">
                    <!-- Unit 3 text -->
                    <h2>UNIT 3: Arrays</h2>
                    <br>
                    <section>
                        <h3>1. Declaring and Creating Arrays in Java</h3><br>
                        <ol>
                            <li>
                                <strong>Declaring Arrays:</strong><br>
                                <ul>
                                    <li>An array is declared by specifying the type of elements it will hold, followed by square brackets (<code>[]</code>), and then the array name.</li>
                                    <pre><code>int[] numbers; // Array of integers
                    String[] names; // Array of strings</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Creating Arrays:</strong><br>
                                <ul>
                                    <li>Arrays are created using the <code>new</code> keyword, followed by the element type and the size (number of elements).</li>
                                    <li>The size is specified in square brackets.</li>
                                    <pre><code>int[] numbers = new int[5]; // Creates an array of size 5
                    String[] names = new String[3]; // Creates an array of size 3</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Initialization with Values:</strong><br>
                                <ul>
                                    <li>Arrays can also be initialized with values at the time of creation.</li>
                                    <pre><code>int[] numbers = {1, 2, 3, 4, 5}; // Initializes array with values
                    String[] names = {"Alice", "Bob", "Charlie"}; // Initializes array with values</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Default Values:</strong><br>
                                <ul>
                                    <li>When an array is created, its elements are initialized to default values:</li>
                                    <li>Primitive types (e.g., <code>int</code>, <code>double</code>) default to <code>0</code>.</li>
                                    <li>Reference types (e.g., <code>String</code>) default to <code>null</code>.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Array Length:</strong><br>
                                <ul>
                                    <li>The length of an array can be obtained using the <code>length</code> attribute.</li>
                                    <pre><code>int[] numbers = new int[5];
                    int arrayLength = numbers.length; // Returns 5</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Array Indexing:</strong><br>
                                <ul>
                                    <li>Arrays in Java are zero-based, so indexing starts from <code>0</code>.</li>
                                    <li>Array elements can be accessed and modified using the index in square brackets (<code>[]</code>).</li>
                                    <pre><code>int[] numbers = {10, 20, 30, 40, 50};
                    int firstNumber = numbers[0]; // Accessing the first element
                    numbers[2] = 35; // Modifying the third element</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Multidimensional Arrays:</strong><br>
                                <ul>
                                    <li>Java supports multidimensional arrays, such as 2D arrays, which can be declared and created similarly.</li>
                                    <pre><code>int[][] matrix = new int[3][3]; // Creates a 3x3 matrix
                    
                    // Initializing a 2D array
                    int[][] matrix = {
                        {1, 2, 3},
                        {4, 5, 6},
                        {7, 8, 9}
                    };</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Declare arrays with appropriate sizes based on the expected usage.</li>
                                    <li>Use meaningful variable names for arrays to improve readability.</li>
                                    <li>Consider using data structures like <code>ArrayList</code> for dynamic arrays when the size may change.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Examples:</strong><br>
                                <ul>
                                    <li>
                                        <strong>Creating and Initializing an Array:</strong><br>
                                        <pre><code>// Declaring and creating an array
                    int[] scores = new int[5];
                    
                    // Initializing an array with values
                    int[] ages = {25, 30, 35, 40, 45};</code></pre>
                                    </li>
                                    <br>
                                    <li>
                                        <strong>Accessing and Modifying Array Elements:</strong><br>
                                        <pre><code>int[] values = {10, 20, 30, 40, 50};
                    
                    // Accessing the second element
                    int secondElement = values[1]; // 20
                    
                    // Modifying the fourth element
                    values[3] = 45; // Changes 40 to 45</code></pre>
                                    </li>
                                </ul>
                            </li>
                        </ol><br>
                    </section>
                    
                    <section>
                        <h3>2. Passing Arrays to Methods</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Arrays can be passed as arguments to methods in Java, just like primitive data types.</li>
                                    <li>Methods receive a reference to the array, not a copy, which allows them to modify the array.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Syntax:</strong><br>
                                <ul>
                                    <li>Declare a method that takes an array as a parameter:</li>
                                    <pre><code>public void processArray(int[] arr) {
                        // Method body
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Passing an Array to a Method:</strong><br>
                                <ul>
                                    <li>When calling a method, pass the array as an argument.</li>
                                    <pre><code>public class ArrayExample {
                        // Method that takes an array as a parameter
                        public static void printArray(int[] arr) {
                            for (int num : arr) {
                                System.out.println(num);
                            }
                        }
                    
                        public static void main(String[] args) {
                            int[] numbers = {10, 20, 30, 40, 50};
                            // Passing the array to the method
                            printArray(numbers);
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Modifying Arrays in Methods:</strong><br>
                                <ul>
                                    <li>Since methods receive a reference to the array, they can modify the original array.</li>
                                    <li>Any changes made to the array in the method are reflected in the original array.</li>
                                    <pre><code>public class ArrayExample {
                        // Method to modify an array by doubling each element
                        public static void doubleArray(int[] arr) {
                            for (int i = 0; i < arr.length; i++) {
                                arr[i] *= 2; // Double each element
                            }
                        }
                    
                        public static void main(String[] args) {
                            int[] numbers = {1, 2, 3, 4, 5};
                            // Passing the array to the method
                            doubleArray(numbers);
                            
                            // Printing the modified array
                            for (int num : numbers) {
                                System.out.println(num);
                            }
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Passing a Portion of an Array:</strong><br>
                                <ul>
                                    <li>It is possible to pass a portion of an array to a method using the <code>Arrays.copyOfRange()</code> method.</li>
                                    <pre><code>import java.util.Arrays;
                    
                    public class ArrayExample {
                        public static void main(String[] args) {
                            int[] numbers = {1, 2, 3, 4, 5, 6, 7, 8, 9};
                    
                            // Passing a portion of the array (from index 2 to 6)
                            int[] subArray = Arrays.copyOfRange(numbers, 2, 7);
                            
                            // Printing the subarray
                            for (int num : subArray) {
                                System.out.println(num);
                            }
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Avoid modifying arrays in methods unless necessary.</li>
                                    <li>Use descriptive method names that reflect the operations performed on the array.</li>
                                </ul>
                            </li>
                        </ol><br>
                    </section>

                    <section>
                        <h3>3. Multidimensional Arrays</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Multidimensional arrays in Java are arrays of arrays.</li>
                                    <li>The most common type of multidimensional array is a 2D array (an array of arrays), but arrays can have more than two dimensions.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Declaration and Creation:</strong><br>
                                <ul>
                                    <li>Declare a multidimensional array by specifying the type of elements and multiple sets of square brackets (<code>[]</code>).</li>
                                    <li>Create a multidimensional array using the <code>new</code> keyword, specifying the size for each dimension.</li>
                                    <pre><code>// Declaration and creation of a 2D array
                                       int[][] matrix = new int[3][3];</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Initialization with Values:</strong><br>
                                <ul>
                                    <li>Multidimensional arrays can be initialized with values at the time of creation.</li>
                                    <pre><code>int[][] matrix = {
                        {1, 2, 3},
                        {4, 5, 6},
                        {7, 8, 9}
                    };</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Accessing and Modifying Elements:</strong><br>
                                <ul>
                                    <li>Access and modify elements using multiple indexes in square brackets (<code>[]</code>), representing each dimension.</li>
                                    <pre><code>int[][] matrix = {
                        {1, 2, 3},
                        {4, 5, 6},
                        {7, 8, 9}
                    };

                    // Accessing an element
                    int value = matrix[1][2]; // Accessing the element at row 1, column 2 (value is 6)

                    // Modifying an element
                    matrix[2][1] = 10; // Changing the value at row 2, column 1 to 10</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Iterating Over Multidimensional Arrays:</strong><br>
                                <ul>
                                    <li>Iterate over a multidimensional array using nested loops.</li>
                                    <pre><code>int[][] matrix = {
                        {1, 2, 3},
                        {4, 5, 6},
                        {7, 8, 9}
                    };

                    for (int i = 0; i &lt; matrix.length; i++) {
                        for (int j = 0; j &lt; matrix[i].length; j++) {
                            System.out.println("Element at [" + i + "][" + j + "] is: " + matrix[i][j]);
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Use descriptive names for multidimensional arrays for clarity.</li>
                                    <li>Be mindful of array bounds to avoid <code>ArrayIndexOutOfBoundsException</code>.</li>
                                    <li>For complex array operations, consider using third-party libraries such as Apache Commons Math or NumPy.</li>
                                </ul>
                            </li>
                        </ol><br>
                    </section>

                    <section>
                        <h3>4. Variable Length Argument Lists</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Variable-length argument lists, also known as varargs, allow methods to accept a variable number of arguments of a specified type.</li>
                                    <li>Varargs are useful when you don't know how many arguments a method will receive.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Syntax:</strong><br>
                                <ul>
                                    <li>Define a varargs parameter by appending <code>...</code> to the type in the method signature.</li>
                                    <li>Inside the method, varargs are treated as an array of the specified type.</li>
                                    <pre><code>public void methodWithVarargs(int... numbers) {
                        // Method body
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Passing Arguments:</strong><br>
                                <ul>
                                    <li>Arguments can be passed as a comma-separated list, or an array can be passed directly.</li>
                                    <pre><code>public class VarargsExample {
                        public static void printNumbers(int... numbers) {
                            for (int num : numbers) {
                                System.out.println(num);
                            }
                        }
                    
                        public static void main(String[] args) {
                            // Passing variable-length arguments
                            printNumbers(1, 2, 3, 4, 5);
                            
                            // Passing an array as an argument
                            int[] numArray = {6, 7, 8, 9, 10};
                            printNumbers(numArray);
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Restrictions and Usage:</strong><br>
                                <ul>
                                    <li>A method can have only one varargs parameter, and it must be the last parameter in the method signature.</li>
                                    <li>Varargs are flexible and useful for handling operations with a variable number of inputs.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Combining Varargs with Other Parameters:</strong><br>
                                <ul>
                                    <li>Varargs can be combined with other parameters in the method signature.</li>
                                    <li>The varargs parameter must always be the last parameter.</li>
                                    <pre><code>public class VarargsExample {
                        public static void greet(String greeting, String... names) {
                            for (String name : names) {
                                System.out.println(greeting + ", " + name + "!");
                            }
                        }
                    
                        public static void main(String[] args) {
                            greet("Hello", "Alice", "Bob", "Charlie");
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Use varargs judiciously, as it can make method signatures less explicit and code harder to understand.</li>
                                    <li>Ensure clarity in the method's purpose when using varargs by using descriptive method names.</li>
                                </ul>
                            </li>
                        </ol>
                    </section><br>
                    <section>
                        <h3>5. Using Command Line Arguments</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Command-line arguments are values passed to a program when it is executed from the command line.</li>
                                    <li>In Java, command-line arguments are provided as an array of strings (<code>String[]</code>) to the <code>main</code> method.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Accessing Command-line Arguments:</strong><br>
                                <ul>
                                    <li>Command-line arguments can be accessed through the <code>String[] args</code> parameter of the <code>main</code> method.</li>
                                    <pre><code>public class CommandLineArgs {
                        public static void main(String[] args) {
                            // Accessing the first command-line argument
                            if (args.length > 0) {
                                System.out.println("First argument: " + args[0]);
                            }
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example Usage:</strong><br>
                                <ul>
                                    <li>To run a Java program with command-line arguments, provide the arguments after the program name when running the program from the command line.</li>
                                    <li>Example:</li>
                                    <pre><code>java CommandLineArgs Hello World</code></pre>
                                    <li>Inside the program, the <code>args</code> array will contain the strings <code>"Hello"</code> and <code>"World"</code>.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Parsing Command-line Arguments:</strong><br>
                                <ul>
                                    <li>Command-line arguments are strings and may need to be parsed into other data types (e.g., integers) depending on the program's requirements.</li>
                                    <li>Use <code>Integer.parseInt()</code> or other parsing methods as needed.</li>
                                    <pre><code>public class CommandLineArgs {
                        public static void main(String[] args) {
                            if (args.length > 0) {
                                // Parse the first command-line argument as an integer
                                int number = Integer.parseInt(args[0]);
                                System.out.println("Parsed integer: " + number);
                            }
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Handling Missing or Invalid Arguments:</strong><br>
                                <ul>
                                    <li>Always check the length of the <code>args</code> array to ensure there are enough arguments before trying to access them.</li>
                                    <li>Handle invalid arguments (e.g., a string that cannot be parsed to an integer) using try-catch blocks.</li>
                                    <pre><code>public class CommandLineArgs {
                        public static void main(String[] args) {
                            if (args.length > 0) {
                                try {
                                    int number = Integer.parseInt(args[0]);
                                    System.out.println("Parsed integer: " + number);
                                } catch (NumberFormatException e) {
                                    System.out.println("Invalid integer: " + args[0]);
                                }
                            } else {
                                System.out.println("No arguments provided.");
                            }
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Provide usage instructions in the program for users when the arguments are missing or invalid.</li>
                                    <li>Keep the number of command-line arguments limited to simplify handling and improve usability.</li>
                                    <li>Use descriptive argument names and clear documentation for better understanding.</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <br>
                </div>

                <div id="unit4" class="formatted-text">
                    <!-- Unit 4 text -->
                    <h2>UNIT 4: Inheritance and Polymorphism in Java</h2>
                    <br>
                    <section>
                        <h3>1. Inheritance</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Inheritance is a core concept in object-oriented programming (OOP) where a class (subclass) derives from another class (superclass), inheriting its fields and methods.</li>
                                    <li>Inheritance promotes code reuse and allows for a hierarchical organization of classes.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Declaration:</strong><br>
                                <ul>
                                    <li>A subclass extends a superclass using the <code>extends</code> keyword.</li>
                                    <pre><code>public class Animal {
                        public void eat() {
                            System.out.println("Animal eats");
                        }
                    }
                    
                    public class Dog extends Animal {
                        public void bark() {
                            System.out.println("Dog barks");
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Superclasses and Subclasses:</strong><br>
                                <ul>
                                    <li>Superclass: The class being inherited from.</li>
                                    <li>Subclass: The class that inherits from the superclass.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Method Overriding:</strong><br>
                                <ul>
                                    <li>Subclasses can provide a specific implementation of a method that is already defined in the superclass.</li>
                                    <li>Use the <code>@Override</code> annotation to indicate method overriding, which can improve code readability and detect errors.</li>
                                    <pre><code>public class Dog extends Animal {
                        @Override
                        public void eat() {
                            System.out.println("Dog eats");
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Advantages of Inheritance:</strong><br>
                                <ul>
                                    <li>Code Reuse: Subclasses inherit methods and fields from the superclass, reducing duplication.</li>
                                    <li>Maintainability: Changes in the superclass automatically propagate to subclasses.</li>
                                    <li>Polymorphism: Inheritance enables polymorphism, where an object can take many forms.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Use inheritance judiciously and only when there is a true is-a relationship between classes.</li>
                                    <li>Keep the superclass general and the subclass specific.</li>
                                    <li>Avoid deep inheritance hierarchies to maintain readability and manageability.</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <br>
                    <section>
                        <h3>2. Superclasses and Subclasses</h3><br>
                        <ol>
                            <li>
                                <strong>Definitions:</strong><br>
                                <ul>
                                    <li>Superclass: A class that is inherited from. It contains common attributes and methods that can be shared with one or more subclasses.</li>
                                    <li>Subclass: A class that inherits from a superclass. It can extend or override the attributes and methods of the superclass.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Declaring a Subclass:</strong><br>
                                <ul>
                                    <li>Use the <code>extends</code> keyword to declare a subclass that inherits from a superclass.</li>
                                    <pre><code>public class Animal {
                        public void eat() {
                            System.out.println("Animal eats");
                        }
                    }
                    
                    public class Dog extends Animal {
                        public void bark() {
                            System.out.println("Dog barks");
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Inheritance Hierarchy:</strong><br>
                                <ul>
                                    <li>Inheritance creates a hierarchy of classes, with the superclass at the top and subclasses below.</li>
                                    <li>Subclasses can inherit from other subclasses, creating a multilevel hierarchy.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Accessing Superclass Members:</strong><br>
                                <ul>
                                    <li>Subclasses inherit fields and methods from the superclass and can access them directly.</li>
                                    <li>The <code>super</code> keyword can be used to explicitly call superclass methods or constructors.</li>
                                    <pre><code>public class Dog extends Animal {
                        public void showBehavior() {
                            super.eat(); // Calls the eat method from the superclass
                            bark(); // Calls the bark method from the subclass
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Overriding Methods:</strong><br>
                                <ul>
                                    <li>Subclasses can override superclass methods to provide specific implementations.</li>
                                    <li>Use the <code>@Override</code> annotation to indicate method overriding.</li>
                                    <pre><code>public class Dog extends Animal {
                        @Override
                        public void eat() {
                            System.out.println("Dog eats");
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Use inheritance to express is-a relationships between classes.</li>
                                    <li>Avoid excessive inheritance levels to keep code understandable and manageable.</li>
                                    <li>Keep superclasses general and subclasses specific.</li>
                                </ul>
                            </li>
                        </ol>
                    </section><br>
                    <section>
                        <h3>3. Protected Members</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Protected members (fields and methods) in Java have <code>protected</code> access, allowing them to be accessible within the class where they are declared, any subclasses, and within the same package.</li>
                                    <li>Protected members provide a balance between encapsulation and inheritance.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Syntax:</strong><br>
                                <ul>
                                    <li>Use the <code>protected</code> keyword to declare a protected field or method in a class.</li>
                                    <pre><code>public class Animal {
                        protected String name;
                        
                        protected void speak() {
                            System.out.println("Animal speaks");
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Accessing Protected Members:</strong><br>
                                <ul>
                                    <li>Protected members can be accessed within the class, any subclasses, and other classes in the same package.</li>
                                    <li>Subclasses can access protected members directly, just like they access public members.</li>
                                    <pre><code>public class Dog extends Animal {
                        public void dogSpeak() {
                            // Accessing protected field and method from the superclass
                            name = "Buddy";
                            speak(); // Calls the speak method from Animal
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Benefits of Protected Access:</strong><br>
                                <ul>
                                    <li>Allows subclasses to access and modify inherited fields and methods, supporting the principle of inheritance.</li>
                                    <li>Provides encapsulation while still enabling code reuse in subclasses.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example:</strong><br>
                                <ul>
                                    <li>The example demonstrates a superclass with protected members and a subclass accessing them.</li>
                                    <pre><code>public class Animal {
                        protected String name;
                    
                        protected void speak() {
                            System.out.println("Animal speaks");
                        }
                    }
                    
                    public class Dog extends Animal {
                        public void dogSpeak() {
                            // Accessing protected field and method from the superclass
                            name = "Buddy";
                            speak(); // Calls the speak method from Animal
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Limitations:</strong><br>
                                <ul>
                                    <li>Protected members are not as encapsulated as private members since they are accessible in subclasses and classes in the same package.</li>
                                    <li>Overusing protected members can lead to tight coupling between classes.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Use protected members judiciously to maintain encapsulation.</li>
                                    <li>Prefer using private members with public or protected getter and setter methods when possible to control access to fields.</li>
                                    <li>Document protected members clearly to indicate their intended use by subclasses.</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <br>
                    <section>
                        <h3>4. Relationship Between Superclasses and Subclasses</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>Inheritance creates a relationship between superclasses and subclasses where the subclass inherits from the superclass.</li>
                                    <li>The relationship allows for code reuse, shared behavior, and a hierarchical structure.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Is-a Relationship:</strong><br>
                                <ul>
                                    <li>Subclasses represent a more specific form of the superclass, known as an is-a relationship.</li>
                                    <li>For example, a <code>Dog</code> class is a specific form of an <code>Animal</code> class, so it can inherit from <code>Animal</code>.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Inheritance Hierarchy:</strong><br>
                                <ul>
                                    <li>Superclasses and subclasses form an inheritance hierarchy, starting with a base class (superclass) at the top.</li>
                                    <li>Subclasses can further extend from other subclasses, creating multiple levels of inheritance.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Method and Field Inheritance:</strong><br>
                                <ul>
                                    <li>Subclasses inherit public and protected fields and methods from the superclass.</li>
                                    <li>Subclasses can access inherited members directly or modify them as needed.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Overriding Methods:</strong><br>
                                <ul>
                                    <li>Subclasses can override methods from the superclass to provide specific implementations.</li>
                                    <li>The <code>@Override</code> annotation can be used to indicate method overriding.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Constructors:</strong><br>
                                <ul>
                                    <li>Subclasses inherit constructors from the superclass, but they must explicitly call a superclass constructor if there isn't a default constructor.</li>
                                    <li>This call is made using the <code>super()</code> keyword at the beginning of the subclass constructor.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Polymorphism:</strong><br>
                                <ul>
                                    <li>Inheritance enables polymorphism, allowing objects to be treated as instances of their superclass type.</li>
                                    <li>This facilitates writing flexible and maintainable code by working with objects through their superclass interface.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example:</strong><br>
                                <ul>
                                    <li>An example demonstrating the relationship between superclasses and subclasses.</li>
                                    <pre><code>public class Animal {
                        public void speak() {
                            System.out.println("Animal speaks");
                        }
                    }
                    
                    public class Dog extends Animal {
                        @Override
                        public void speak() {
                            System.out.println("Dog barks");
                        }
                    }
                    
                    public class Test {
                        public static void main(String[] args) {
                            Animal myAnimal = new Dog(); // Polymorphism: Dog object treated as Animal
                            myAnimal.speak(); // Outputs "Dog barks"
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Use inheritance judiciously to model is-a relationships, not has-a relationships.</li>
                                    <li>Avoid deep inheritance hierarchies for simplicity and readability.</li>
                                    <li>Prefer composition over inheritance in cases where the is-a relationship is not clear.</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <br>
                    <section>
                        <h3>5. Constructors in Subclasses</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>A constructor in a subclass is responsible for initializing the new instance of the subclass.</li>
                                    <li>Subclass constructors may need to call the superclass constructor to ensure the superclass part of the object is properly initialized.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Calling Superclass Constructors:</strong><br>
                                <ul>
                                    <li>Subclasses call the superclass constructor using the <code>super()</code> keyword.</li>
                                    <li>This call must be the first statement in the subclass constructor.</li>
                                    <li>If no explicit call to the superclass constructor is made, Java will implicitly call the no-argument constructor of the superclass (if it exists).</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Passing Arguments to Superclass Constructor:</strong><br>
                                <ul>
                                    <li>Arguments can be passed to the superclass constructor from the subclass constructor using <code>super()</code>.</li>
                                    <pre><code>public class Animal {
                        private String name;
                    
                        public Animal(String name) {
                            this.name = name;
                            System.out.println("Animal: " + name);
                        }
                    }
                    
                    public class Dog extends Animal {
                        public Dog(String name) {
                            super(name); // Calls the superclass constructor with name argument
                            System.out.println("Dog: " + name);
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Constructor Overloading:</strong><br>
                                <ul>
                                    <li>Subclasses can overload constructors just like methods, allowing for multiple constructors with different parameters.</li>
                                    <li>If the superclass does not have a no-argument constructor, subclasses must call one of the superclass constructors explicitly.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Inheritance of Constructors:</strong><br>
                                <ul>
                                    <li>Subclass constructors do not inherit constructors from the superclass.</li>
                                    <li>Each subclass must define its own constructors and explicitly call a superclass constructor.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Default Constructor in Subclasses:</strong><br>
                                <ul>
                                    <li>If a subclass does not define any constructors, a default no-argument constructor is provided by the compiler, which calls the no-argument constructor of the superclass.</li>
                                    <li>If the superclass does not have a no-argument constructor, an explicit call to a superclass constructor must be made.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example of Constructor Chaining:</strong><br>
                                <ul>
                                    <li>Chaining of constructors using the <code>super()</code> keyword can help to create a chain of initialization starting from the base class.</li>
                                    <pre><code>public class Animal {
                        public Animal(String name) {
                            System.out.println("Animal: " + name);
                        }
                    }
                    
                    public class Dog extends Animal {
                        public Dog(String name) {
                            super(name); // Calls the superclass constructor
                            System.out.println("Dog: " + name);
                        }
                    }
                    
                    public class GermanShepherd extends Dog {
                        public GermanShepherd(String name) {
                            super(name); // Calls the Dog constructor, which in turn calls the Animal constructor
                            System.out.println("German Shepherd: " + name);
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Always call the appropriate superclass constructor using <code>super()</code> in subclass constructors.</li>
                                    <li>Use constructor overloading for flexibility and to provide various options for initializing objects.</li>
                                    <li>Ensure superclass constructors are called in the correct order to initialize inherited fields and methods properly.</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <br>
                    <section>
                        <h3>6. Object Class</h3><br>
                        <ol>
                            <li>
                                <strong>Definition:</strong><br>
                                <ul>
                                    <li>The <code>Object</code> class is the root class of all classes in Java.</li>
                                    <li>All classes in Java inherit directly or indirectly from the <code>Object</code> class.</li>
                                    <li>It provides common methods that can be overridden by subclasses as needed.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Methods in the Object Class:</strong><br>
                                <ul>
                                    <li><code>equals(Object obj)</code>: Compares this object to another for equality.</li>
                                    <li><code>hashCode()</code>: Returns a hash code for the object.</li>
                                    <li><code>toString()</code>: Returns a string representation of the object.</li>
                                    <li><code>getClass()</code>: Returns the runtime class of the object.</li>
                                    <li><code>clone()</code>: Creates and returns a copy of the object (requires implementing <code>Cloneable</code> interface).</li>
                                    <li><code>notify()</code>, <code>notifyAll()</code>, and <code>wait()</code>: Used for thread synchronization.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Overriding Methods from the Object Class:</strong><br>
                                <ul>
                                    <li>Subclasses can override methods from the <code>Object</code> class to provide specific functionality.</li>
                                    <li>For example, <code>equals(Object obj)</code> can be overridden to provide custom equality comparison.</li>
                                    <li><code>toString()</code> can be overridden to return a meaningful string representation of the object.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong><code>toString()</code> Method:</strong><br>
                                <ul>
                                    <li>By default, <code>toString()</code> returns the class name followed by the "@" symbol and the object's hash code.</li>
                                    <li>Override <code>toString()</code> to provide a more meaningful representation of the object.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong><code>equals(Object obj)</code> Method:</strong><br>
                                <ul>
                                    <li>By default, <code>equals</code> compares references (memory addresses) of two objects.</li>
                                    <li>Override <code>equals</code> to compare object properties for equality, such as fields in a class.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong><code>hashCode()</code> Method:</strong><br>
                                <ul>
                                    <li>Works with <code>equals</code> for efficient storage in hash-based collections like <code>HashMap</code>.</li>
                                    <li>Override <code>hashCode()</code> when <code>equals</code> is overridden to maintain consistency.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>When overriding <code>equals()</code>, also override <code>hashCode()</code> for proper functioning in collections.</li>
                                    <li>Use <code>@Override</code> annotation when overriding methods from <code>Object</code> for better code readability and error detection.</li>
                                    <li>When overriding <code>toString()</code>, provide a meaningful representation of the object for easy debugging.</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <br>
                    <section>
                        <h3>7. Abstract Classes and Methods</h3><br>
                        <ol>
                            <li>
                                <strong>Abstract Classes:</strong><br>
                                <ul>
                                    <li>An abstract class is a class that cannot be instantiated on its own and is declared with the <code>abstract</code> keyword.</li>
                                    <li>Abstract classes may contain abstract methods, which are methods without a body (implementation).</li>
                                    <li>Abstract classes are meant to be extended by other classes, which provide implementations for the abstract methods.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Abstract Methods:</strong><br>
                                <ul>
                                    <li>Abstract methods are methods declared in an abstract class with the <code>abstract</code> keyword and without an implementation.</li>
                                    <li>Subclasses extending an abstract class must provide an implementation for each abstract method or be declared abstract themselves.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Syntax:</strong><br>
                                <ul>
                                    <li>Declare an abstract class with the <code>abstract</code> keyword:</li>
                                    <pre><code>public abstract class Animal {
                        public abstract void sound();
                    }</code></pre>
                                    <li>Declare an abstract method in an abstract class:</li>
                                    <pre><code>public abstract void sound();</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Extending Abstract Classes:</strong><br>
                                <ul>
                                    <li>Subclasses that extend an abstract class must provide concrete implementations for all abstract methods.</li>
                                    <li>If a subclass does not implement all abstract methods, it must also be declared abstract.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Advantages of Abstract Classes and Methods:</strong><br>
                                <ul>
                                    <li>Provide a blueprint for subclasses, ensuring they implement necessary methods.</li>
                                    <li>Allow for the creation of a common base class for related classes.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example:</strong><br>
                                <ul>
                                    <li>The example demonstrates the use of an abstract class and method.</li>
                                    <pre><code>public abstract class Animal {
                        public abstract void sound(); // Abstract method
                    
                        public void eat() {
                            System.out.println("Animal eats");
                        }
                    }
                    
                    public class Dog extends Animal {
                        @Override
                        public void sound() {
                            System.out.println("Dog barks"); // Implementing the abstract method
                    }
                    }
                    
                    public class Test {
                        public static void main(String[] args) {
                            Animal myDog = new Dog(); // Polymorphism
                            myDog.sound(); // Outputs "Dog barks"
                            myDog.eat(); // Outputs "Animal eats"
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Use abstract classes and methods to define a contract for subclasses and establish a common interface.</li>
                                    <li>Document abstract methods clearly to guide subclasses in implementing the required behavior.</li>
                                    <li>Choose between abstract classes and interfaces based on the design needs (use abstract classes for common implementation and state).</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <br>
                    <section>
                        <h3>8. Final Methods and Classes</h3><br>
                        <ol>
                            <li>
                                <strong>Final Methods:</strong><br>
                                <ul>
                                    <li>A method declared with the <code>final</code> keyword cannot be overridden by subclasses.</li>
                                    <li>Using <code>final</code> ensures that the method's implementation is preserved across the class hierarchy.</li>
                                    <li>This can improve performance and reliability as the method behavior remains consistent.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Syntax:</strong><br>
                                <ul>
                                    <li>Declare a method as final using the <code>final</code> keyword:</li>
                                    <pre><code>public class Animal {
                        public final void eat() {
                            System.out.println("Animal eats");
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Final Classes:</strong><br>
                                <ul>
                                    <li>A class declared with the <code>final</code> keyword cannot be subclassed.</li>
                                    <li>This enforces a strict design decision and helps prevent further modifications to the class.</li>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Syntax:</strong><br>
                                <ul>
                                    <li>Declare a class as final using the <code>final</code> keyword:</li>
                                    <pre><code>public final class Animal {
                        public void eat() {
                            System.out.println("Animal eats");
                        }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Use Cases for Final Methods and Classes:</strong><br>
                                <ul>
                                    <li><strong>Final Methods:</strong></li>
                                    <ul>
                                        <li>Prevents unintended method overrides.</li>
                                        <li>Useful when a method's functionality should remain unchanged.</li>
                                    </ul>
                                    <li><strong>Final Classes:</strong></li>
                                    <ul>
                                        <li>Prevents any subclassing, thus ensuring the class remains as is.</li>
                                        <li>Useful for security, stability, or design reasons.</li>
                                    </ul>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Example of Final Methods and Classes:</strong><br>
                                <ul>
                                    <li>An example showing the use of final methods and classes.</li>
                                    <pre><code>public final class Animal {
                        public final void eat() {
                            System.out.println("Animal eats");
                        }
                    }
                    
                    // This will cause a compilation error because `Animal` is final
                    // and cannot be subclassed.
                    // public class Dog extends Animal { }
                    
                    public class Plant {
                        public final void grow() {
                            System.out.println("Plant grows");
                        }
                    }
                    
                    public class Flower extends Plant {
                        // This will cause a compilation error because `grow()` is final
                        // and cannot be overridden.
                        // @Override
                        // public void grow() {
                        //     System.out.println("Flower grows");
                        // }
                    }</code></pre>
                                </ul>
                            </li><br>
                            <li>
                                <strong>Best Practices:</strong><br>
                                <ul>
                                    <li>Use final methods when you want to guarantee a specific implementation.</li>
                                    <li>Use final classes when you want to prevent inheritance and protect the integrity of the class.</li>
                                    <li>Avoid overusing final, as it can limit flexibility and the ability to extend classes.</li>
                                </ul>
                            </li>
                        </ol>
                    </section>
                    <br>
                    <section>
                        <h3>9. Polymorphism Examples and Interfaces</h3><br>
                        <article>
                            <h4>Polymorphism</h4>
                            <ol>
                                <li>
                                    <strong>Definition:</strong><br>
                                    <ul>
                                        <li>Polymorphism is the ability of a method or object to take on multiple forms.</li>
                                        <li>It allows a single method to have different implementations or a reference of a superclass type to point to different subclass objects.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Method Overriding:</strong><br>
                                    <ul>
                                        <li>A subclass provides its own implementation of a method inherited from its superclass.</li>
                                        <li>When the method is called on a superclass reference, the method in the subclass is executed.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Example of Polymorphism:</strong><br>
                                    <pre><code>public class Animal {
                        public void speak() {
                            System.out.println("Animal speaks");
                        }
                    }
                    
                    public class Dog extends Animal {
                        @Override
                        public void speak() {
                            System.out.println("Dog barks");
                        }
                    }
                    
                    public class Cat extends Animal {
                        @Override
                        public void speak() {
                            System.out.println("Cat meows");
                        }
                    }
                    
                    public class TestPolymorphism {
                        public static void main(String[] args) {
                            Animal myAnimal = new Dog(); // myAnimal is a Dog
                            myAnimal.speak(); // Outputs "Dog barks"
                    
                            myAnimal = new Cat(); // myAnimal now points to a Cat
                            myAnimal.speak(); // Outputs "Cat meows"
                        }
                    }</code></pre>
                                </li>
                            </ol>
                        </article><br>
                        <article>
                            <h4>Interfaces</h4>
                            <ol>
                                <li>
                                    <strong>Definition:</strong><br>
                                    <ul>
                                        <li>An interface is a reference type that specifies a set of methods without implementation.</li>
                                        <li>A class that implements an interface must provide concrete implementations for all methods declared in the interface.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Declaring an Interface:</strong><br>
                                    <ul>
                                        <li>Use the <code>interface</code> keyword to declare an interface:</li>
                                        <pre><code>public interface Animal {
                        void eat(); // Abstract method
                    }</code></pre>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Implementing an Interface:</strong><br>
                                    <ul>
                                        <li>Use the <code>implements</code> keyword to declare a class that implements an interface.</li>
                                        <li>The class must provide concrete implementations for all methods declared in the interface.</li>
                                    </ul>
                                    <pre><code>public class Dog implements Animal {
                        @Override
                        public void eat() {
                            System.out.println("Dog eats");
                        }
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Multiple Interfaces:</strong><br>
                                    <ul>
                                        <li>A class can implement multiple interfaces, promoting flexibility and code reuse.</li>
                                    </ul>
                                    <pre><code>public interface Swimmer {
                        void swim();
                    }
                    
                    public class Dog implements Animal, Swimmer {
                        @Override
                        public void eat() {
                            System.out.println("Dog eats");
                        }
                    
                        @Override
                        public void swim() {
                            System.out.println("Dog swims");
                        }
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Polymorphism with Interfaces:</strong><br>
                                    <ul>
                                        <li>Interfaces allow for polymorphism by providing a common contract that multiple classes can implement.</li>
                                        <li>Objects can be treated as instances of the interface, regardless of their actual class.</li>
                                    </ul>
                                    <pre><code>public class TestInterfaces {
                        public static void main(String[] args) {
                            Animal myAnimal = new Dog(); // myAnimal is a Dog
                            myAnimal.eat(); // Outputs "Dog eats"
                    
                            Swimmer mySwimmer = new Dog(); // mySwimmer is a Dog
                            mySwimmer.swim(); // Outputs "Dog swims"
                        }
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Best Practices:</strong><br>
                                    <ul>
                                        <li>Use polymorphism to write flexible and maintainable code.</li>
                                        <li>Use interfaces to define contracts and enable multiple inheritance.</li>
                                        <li>Document interfaces clearly to guide implementing classes.</li>
                                    </ul>
                                </li>
                            </ol>
                        </article>
                    </section>
                    <br>
                
                </div>

                <div id="unit5" class="formatted-text">
                    <!-- Unit 5 text -->
                    <h2>UNIT 5: Exception-handling and Java script</h2>
                    <br>
                    <section>
                        <h3>1. Exception Handling Overview</h3><br>
                        <article>
                            <ol>
                                <li>
                                    <strong>Definition:</strong><br>
                                    <ul>
                                        <li>Exception handling is a mechanism in Java that allows a program to handle runtime errors and exceptional conditions.</li>
                                        <li>An exception is an event that occurs during the execution of a program, disrupting the normal flow of control.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Types of Exceptions:</strong><br>
                                    <ul>
                                        <li>Checked Exceptions: These must be either caught or declared in the method signature using the <code>throws</code> keyword.</li>
                                        <li>Unchecked Exceptions: Also known as runtime exceptions, these are not required to be caught or declared.</li>
                                        <li>Errors: Severe problems such as <code>OutOfMemoryError</code> that applications typically should not catch.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Exception Handling Keywords:</strong><br>
                                    <ul>
                                        <li><code>try</code>: Block of code where exceptions may occur.</li>
                                        <li><code>catch</code>: Block of code to handle the exception.</li>
                                        <li><code>finally</code>: Block of code that executes regardless of whether an exception is thrown.</li>
                                        <li><code>throws</code>: Used in method signatures to declare the types of exceptions that the method may throw.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Handling Exceptions:</strong><br>
                                    <pre><code>try {
                        int result = 10 / 0; // May throw an ArithmeticException
                    } catch (ArithmeticException e) {
                        System.out.println("Cannot divide by zero");
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Multiple Catch Blocks:</strong><br>
                                    <pre><code>try {
                        int[] numbers = new int[3];
                        int number = numbers[5]; // May throw ArrayIndexOutOfBoundsException
                    } catch (ArrayIndexOutOfBoundsException e) {
                        System.out.println("Index out of bounds");
                    } catch (Exception e) {
                        System.out.println("An unexpected exception occurred");
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>The <code>finally</code> Block:</strong><br>
                                    <ul>
                                        <li>The <code>finally</code> block is optional and executes after the <code>try</code> and <code>catch</code> blocks, regardless of whether an exception is thrown.</li>
                                        <li>It is commonly used for resource cleanup (e.g., closing files or network connections).</li>
                                    </ul>
                                    <pre><code>try {
                        // Code that may throw an exception
                    } catch (Exception e) {
                        // Handle the exception
                    } finally {
                        // Code that always executes, such as resource cleanup
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Throwing Exceptions:</strong><br>
                                    <pre><code>public void checkNumber(int number) {
                        if (number < 0) {
                            throw new IllegalArgumentException("Number must be non-negative");
                        }
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Declaring Exceptions:</strong><br>
                                    <pre><code>public void riskyOperation() throws IOException {
                        // Method body that may throw an IOException
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Best Practices:</strong><br>
                                    <ul>
                                        <li>Catch specific exceptions rather than general exceptions (e.g., <code>Exception</code>) for better error handling.</li>
                                        <li>Avoid catching <code>Throwable</code> or <code>Error</code> unless absolutely necessary.</li>
                                        <li>Use <code>finally</code> blocks for resource cleanup to ensure proper release of resources.</li>
                                        <li>Declare only exceptions that are truly unexpected and cannot be handled within the method.</li>
                                    </ul>
                                </li>
                            </ol>
                        </article>
                    </section>
                    <br>
                    <section>
                        <h3>2. Arithmetic Exception</h3><br>
                        <article>
                            <ol>
                                <li>
                                    <strong>Definition:</strong><br>
                                    <ul>
                                        <li><code>ArithmeticException</code> is an unchecked exception that is thrown when an arithmetic operation results in an invalid calculation, such as division by zero.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Handling ArithmeticException:</strong><br>
                                    <pre><code>try {
                        int result = 10 / 0; // This will cause ArithmeticException
                    } catch (ArithmeticException e) {
                        System.out.println("Error: Division by zero is not allowed.");
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Best Practices:</strong><br>
                                    <ul>
                                        <li>Avoid arithmetic errors by checking for potential issues before performing calculations.</li>
                                        <li>Provide meaningful error messages in the <code>catch</code> block to help with debugging and user understanding.</li>
                                    </ul>
                                </li>
                            </ol>
                        </article>
                        <h3>3. InputMismatch Exception</h3><br>
                        <article>
                            <ol >
                                <li>
                                    <strong>Definition:</strong><br>
                                    <ul>
                                        <li><code>InputMismatchException</code> is an unchecked exception thrown by the <code>Scanner</code> class when the input does not match the expected data type.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Handling InputMismatchException:</strong><br>
                                    <pre><code>import java.util.InputMismatchException;
                    import java.util.Scanner;
                    
                    public class Example {
                        public static void main(String[] args) {
                            Scanner scanner = new Scanner(System.in);
                            try {
                                System.out.print("Enter an integer: ");
                                int num = scanner.nextInt(); // May throw InputMismatchException
                                System.out.println("You entered: " + num);
                            } catch (InputMismatchException e) {
                                System.out.println("Error: Please enter a valid integer.");
                            } finally {
                                scanner.close(); // Always close the Scanner
                            }
                        }
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Best Practices:</strong><br>
                                    <ul>
                                        <li>Check input format and data types before processing to avoid exceptions.</li>
                                        <li>Provide user-friendly error messages in the <code>catch</code> block.</li>
                                        <li>Use <code>finally</code> block to close resources like <code>Scanner</code> and prevent resource leaks.</li>
                                    </ul>
                                </li>
                            </ol>
                        </article>
                        <h3>4. When to Use Exception Handling</h3><br>
                        <article>
                            <ol >
                                <li>
                                    <strong>Appropriate Scenarios for Exception Handling:</strong><br>
                                    <ul>
                                        <li>Unexpected Errors: Use exception handling for unexpected errors during program execution (e.g., file not found, division by zero).</li>
                                        <li>Input/Output Operations: When performing I/O operations, such as file handling or network communication, where many issues can arise.</li>
                                        <li>Data Validation: When user input needs to be validated, and improper input can lead to exceptions.</li>
                                        <li>Resource Management: To handle exceptions that may arise when allocating and deallocating resources such as memory, file streams, or network connections.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Best Practices for Using Exception Handling:</strong><br>
                                    <ul>
                                        <li>Design for Errors: Anticipate possible errors in the code and handle them gracefully.</li>
                                        <li>Use Specific Exceptions: Catch specific exceptions instead of general exceptions (e.g., <code>Exception</code>) for better error handling.</li>
                                        <li>Use Finally Block: Use a <code>finally</code> block to release resources and perform cleanup regardless of whether an exception is thrown.</li>
                                        <li>Avoid Suppressing Exceptions: Don't catch exceptions without handling them properly or logging information about them.</li>
                                        <li>Re-throw Exceptions: Re-throw exceptions when necessary, such as when the exception should be propagated to a higher-level method.</li>
                                        <li>Custom Exceptions: Create custom exceptions when the existing exceptions do not adequately represent specific error scenarios in your application.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Exceptions vs. Errors:</strong><br>
                                    <ul>
                                        <li>Exceptions: Represent problems in the application that can be anticipated and handled (e.g., <code>IOException</code>, <code>ArithmeticException</code>).</li>
                                        <li>Errors: Represent severe problems that are generally beyond the control of the application (e.g., <code>OutOfMemoryError</code>, <code>StackOverflowError</code>).</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Common Mistakes to Avoid:</strong><br>
                                    <ul>
                                        <li>Catching All Exceptions: Avoid catching all exceptions using <code>catch (Exception e)</code>, as it may hide critical problems.</li>
                                        <li>Ignoring Exceptions: Don't ignore exceptions in <code>catch</code> blocks; provide meaningful error handling or re-throw the exception.</li>
                                        <li>Overusing Exception Handling: Avoid using exceptions for normal control flow, as it can lead to inefficient and confusing code.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Example:</strong><br>
                                    <ul>
                                        <li>An example of when to use exception handling for file reading.</li>
                                    </ul>
                                    <pre><code>import java.io.BufferedReader;
                    import java.io.FileReader;
                    import java.io.IOException;
                    
                    public class FileReaderExample {
                        public void readFile(String filePath) {
                            BufferedReader reader = null;
                            try {
                                reader = new BufferedReader(new FileReader(filePath));
                                String line;
                                while ((line = reader.readLine()) != null) {
                                    System.out.println(line);
                                }
                            } catch (IOException e) {
                                System.out.println("Error reading file: " + e.getMessage());
                            } finally {
                                if (reader != null) {
                                    try {
                                        reader.close();
                                    } catch (IOException e) {
                                        System.out.println("Error closing reader: " + e.getMessage());
                                    }
                                }
                            }
                        }
                    }</code></pre>
                                </li>
                            </ol>
                        </article>
                    </section>
                    <br>
                    <section>
                        <h3>5. Java Exception Hierarchy</h3><br>
                        <article>
                            <ol>
                                <li>
                                    <strong>Hierarchy Overview:</strong><br>
                                    <ul>
                                        <li>Java exceptions are organized in a hierarchy of classes, with <code>Throwable</code> as the root class.</li>
                                        <li><code>Throwable</code> has two main subclasses: <code>Error</code> and <code>Exception</code>.</li>
                                        <li>Exceptions are further divided into checked and unchecked (runtime) exceptions.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Throwable:</strong><br>
                                    <ul>
                                        <li><code>Throwable</code> is the root class of the exception hierarchy.</li>
                                        <li>It includes <code>Exception</code> and <code>Error</code> as its two main subclasses.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Errors:</strong><br>
                                    <ul>
                                        <li>Subclass of <code>Throwable</code>.</li>
                                        <li>Represents severe problems that typically cannot be handled by the application (e.g., <code>OutOfMemoryError</code>, <code>StackOverflowError</code>).</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Exceptions:</strong><br>
                                    <ul>
                                        <li>Subclass of <code>Throwable</code>.</li>
                                        <li>Represents problems that can be anticipated and handled within the application.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Types of Exceptions:</strong><br>
                                    <ul>
                                        <li><strong>Checked Exceptions:</strong>
                                            <ul>
                                                <li>Inherit from <code>Exception</code> but not from <code>RuntimeException</code>.</li>
                                                <li>Must be declared in the method signature using the <code>throws</code> keyword or handled with a <code>try-catch</code> block.</li>
                                                <li>Examples: <code>IOException</code>, <code>SQLException</code>, <code>FileNotFoundException</code>.</li>
                                            </ul>
                                        </li>
                                        <li><strong>Unchecked (Runtime) Exceptions:</strong>
                                            <ul>
                                                <li>Inherit from <code>RuntimeException</code>.</li>
                                                <li>Do not need to be declared in the method signature or handled explicitly.</li>
                                                <li>Examples: <code>NullPointerException</code>, <code>ArithmeticException</code>, <code>ArrayIndexOutOfBoundsException</code>.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Exception Hierarchy in Detail:</strong><br>
                                    <ul>
                                        <li><code>Throwable</code>
                                            <ul>
                                                <li><code>Error</code>: Represents serious problems.
                                                    <ul>
                                                        <li><code>OutOfMemoryError</code>, <code>StackOverflowError</code>, etc.</li>
                                                    </ul>
                                                </li>
                                                <li><code>Exception</code>: Represents exceptions that need to be caught and handled.
                                                    <ul>
                                                        <li><code>IOException</code>: File I/O problems.</li>
                                                        <li><code>SQLException</code>: Database access problems.</li>
                                                        <li><code>RuntimeException</code>: Represents unchecked exceptions.
                                                            <ul>
                                                                <li><code>NullPointerException</code></li>
                                                                <li><code>ArithmeticException</code></li>
                                                                <li><code>ArrayIndexOutOfBoundsException</code></li>
                                                                <li>And others...</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Using Exceptions:</strong><br>
                                    <ul>
                                        <li>Catch specific exceptions for better error handling.</li>
                                        <li>Use custom exceptions if necessary for more specific error reporting.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Best Practices:</strong><br>
                                    <ul>
                                        <li>Understand the hierarchy to handle exceptions effectively.</li>
                                        <li>Handle checked exceptions using <code>try-catch</code> blocks or declare them using the <code>throws</code> keyword.</li>
                                        <li>Avoid catching <code>Throwable</code> or <code>Error</code> unless necessary.</li>
                                        <li>Properly document exceptions in your methods to guide other developers.</li>
                                    </ul>
                                </li>
                            </ol>
                        </article>
                        <h3>6. Finally Block</h3><br>
                        <article>
                            <ol >
                                <li>
                                    <strong>Definition:</strong><br>
                                    <ul>
                                        <li>The <code>finally</code> block is an optional block of code that follows the <code>try</code> and <code>catch</code> blocks in Java.</li>
                                        <li>It is used to execute code regardless of whether an exception is thrown in the <code>try</code> block.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Purpose:</strong><br>
                                    <ul>
                                        <li>The <code>finally</code> block is often used for resource cleanup (e.g., closing files or database connections) to ensure resources are properly released.</li>
                                        <li>It provides a guarantee that the code inside the block will execute, even if an exception occurs.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Syntax:</strong><br>
                                    <ul>
                                        <li>A <code>try-catch-finally</code> block has the following syntax:</li>
                                    </ul>
                                    <pre><code>try {
                        // Code that may throw an exception
                    } catch (Exception e) {
                        // Code to handle the exception
                    } finally {
                        // Code that always executes, whether an exception is thrown or not
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Behavior:</strong><br>
                                    <ul>
                                        <li>The <code>finally</code> block executes after the <code>try</code> and <code>catch</code> blocks, regardless of whether an exception was thrown.</li>
                                        <li>The <code>finally</code> block executes even if there is an exception not caught by a <code>catch</code> block.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Common Uses of Finally Block:</strong><br>
                                    <ul>
                                        <li>Resource Cleanup: Close files, network connections, database connections, or other resources.</li>
                                        <li>Releasing Locks: Release synchronization locks that were acquired in the <code>try</code> block.</li>
                                        <li>Logging: Perform logging or other monitoring activities that should always occur.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Example:</strong><br>
                                    <ul>
                                        <li>An example demonstrating the use of the <code>finally</code> block for resource cleanup.</li>
                                    </ul>
                                    <pre><code>import java.io.BufferedReader;
                    import java.io.FileReader;
                    import java.io.IOException;
                    
                    public class FileReaderExample {
                        public void readFile(String filePath) {
                            BufferedReader reader = null;
                            try {
                                reader = new BufferedReader(new FileReader(filePath));
                                String line;
                                while ((line = reader.readLine()) != null) {
                                    System.out.println(line);
                                }
                            } catch (IOException e) {
                                System.out.println("Error reading file: " + e.getMessage());
                            } finally {
                                if (reader != null) {
                                    try {
                                        reader.close();
                                    } catch (IOException e) {
                                        System.out.println("Error closing reader: " + e.getMessage());
                                    }
                                }
                            }
                        }
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Best Practices:</strong><br>
                                    <ul>
                                        <li>Use the <code>finally</code> block for resource cleanup to ensure that resources are released properly.</li>
                                        <li>Avoid using <code>return</code> statements in the <code>try</code> and <code>catch</code> blocks to allow the <code>finally</code> block to execute.</li>
                                        <li>Handle exceptions in the <code>finally</code> block appropriately, especially when dealing with resources.</li>
                                    </ul>
                                </li>
                            </ol>
                        </article>
                    </section>
                    <br>
                    <section>
                        <h3>7. Introduction to Java Applets</h3><br>
                        <article>
                            <ol>
                                <li>
                                    <strong>Definition:</strong><br>
                                    <ul>
                                        <li>Java applets are small applications written in Java that can be embedded in web pages and run in a browser.</li>
                                        <li>They were once popular for creating interactive and dynamic web content.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Applet Lifecycle:</strong><br>
                                    <ul>
                                        <li>The applet lifecycle consists of the following methods:
                                            <ul>
                                                <li><code>init()</code>: Called when the applet is initialized; used for setting up resources.</li>
                                                <li><code>start()</code>: Called when the applet starts; used to begin the applet's operation.</li>
                                                <li><code>stop()</code>: Called when the applet is stopped; used to suspend the applet's operation.</li>
                                                <li><code>destroy()</code>: Called when the applet is destroyed; used to release resources.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Applet Structure:</strong><br>
                                    <ul>
                                        <li>Applets are subclasses of <code>java.applet.Applet</code> or <code>javax.swing.JApplet</code>.</li>
                                        <li>They can override lifecycle methods and other methods as needed.</li>
                                    </ul>
                                    <pre><code>import java.applet.Applet;
                    import java.awt.Graphics;
                    
                    public class HelloWorldApplet extends Applet {
                        @Override
                        public void paint(Graphics g) {
                            g.drawString("Hello, World!", 20, 20);
                        }
                    }</code></pre>
                                </li><br>
                                <li>
                                    <strong>Embedding Applets in Web Pages:</strong><br>
                                    <ul>
                                        <li>Applets can be embedded in HTML pages using the <code>&lt;applet&gt;</code> or <code>&lt;object&gt;</code> tags.</li>
                                    </ul>
                                    <pre><code>&lt;applet code="HelloWorldApplet.class" width="200" height="50"&gt;&lt;/applet&gt;</code></pre>
                                </li><br>
                                <li>
                                    <strong>Security and Sandboxing:</strong><br>
                                    <ul>
                                        <li>Applets run in a sandboxed environment with limited access to the host system.</li>
                                        <li>Security restrictions are applied to prevent applets from performing unauthorized actions.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Limitations of Java Applets:</strong><br>
                                    <ul>
                                        <li>Applets require a compatible browser and Java plugin to run, which has become less common over time.</li>
                                        <li>Security concerns and compatibility issues have led to decreased support for applets in modern browsers.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Alternatives to Applets:</strong><br>
                                    <ul>
                                        <li>Modern web technologies such as JavaScript, HTML5, and CSS3 provide better alternatives for creating interactive and dynamic web content.</li>
                                        <li>JavaFX is another option for creating rich media applications, with the ability to deploy as web applications.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Best Practices:</strong><br>
                                    <ul>
                                        <li>Avoid using applets for new projects due to browser compatibility and security concerns.</li>
                                        <li>For existing projects using applets, consider migrating to modern web technologies or standalone Java applications.</li>
                                    </ul>
                                </li>
                            </ol>
                        </article>
                    </section>
                    <section>
                        <h3>8. JavaScript</h3><br>
                        <article>
                            <ol >
                                <li>
                                    <strong>Definition:</strong><br>
                                    <p>JavaScript (JS) is a high-level, interpreted programming language primarily used for creating interactive and dynamic content on web pages. It is often used alongside HTML and CSS for front-end web development.</p>
                                </li><br>
                                <li>
                                    <strong>Introduction to Clientside Scripting</strong><br>
                                    <ul>
                                        <li><strong>Definition:</strong> Client-side scripting involves writing scripts that run on the client (user's browser) to create dynamic and interactive web pages.</li>
                                        <li><strong>Common Languages:</strong> JavaScript is the most common language used for client-side scripting.</li>
                                        <li><strong>Functionality:</strong> Manipulate the Document Object Model (DOM), handle events, validate forms, create animations, and perform AJAX requests.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Syntax Basics</strong><br>
                                    <ul>
                                        <li><strong>JavaScript Syntax:</strong> Follows C-like syntax with statements ending in semicolons.</li>
                                        <li><strong>Variable Declaration:</strong> Use <code>let</code> and <code>const</code> for block-scoped variables, or <code>var</code> for function-scoped variables.</li>
                                        <li><strong>Control Structures:</strong> Similar to other languages (<code>if</code>, <code>while</code>, <code>for</code>, etc.).</li>
                                        <li><strong>Functions:</strong> Defined using the <code>function</code> keyword or arrow function syntax (<code>=&gt;</code>).</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Operators</strong><br>
                                    <ul>
                                        <li><strong>Arithmetic Operators:</strong> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>**</code> (exponentiation).</li>
                                        <li><strong>Comparison Operators:</strong> <code>==</code>, <code>===</code>, <code>!=</code>, <code>!==</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>.</li>
                                        <li><strong>Logical Operators:</strong> <code>&amp;&amp;</code>, <code>||</code>, <code>!</code>.</li>
                                    </ul>
                                </li><br>
                                <li>
                                    <strong>Comparisons</strong><br>
                                    <ul>
                                        <li><strong>Equality Operators:</strong> <code>==</code> vs <code>===</code>: Double equals performs type coercion; triple equals checks both value and type.</li>
                                        <li><strong>Comparison Operators:</strong> Used for conditional statements and loops.</li>
                                    </ul>
                                </li>
                            </ol>
                        </article>
                    </section>
                    <br>
                    <section>
                        <h3>13. Statements</h3><br>
                        <article>
                            <ul>
                                <li>
                                    <strong>Conditional Statements:</strong>
                                    <ul>
                                        <li><code>if</code>, <code>else if</code>, and <code>else</code> for branching logic.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Looping Statements:</strong>
                                    <ul>
                                        <li><code>for</code>, <code>while</code>, and <code>do...while</code> for iteration.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Switch Statement:</strong>
                                    <ul>
                                        <li>Used for multiple branching based on a value.</li>
                                    </ul>
                                </li>
                            </ul>
                        </article>
                    </section>
                    <section>
                        <h3>14. Loops</h3><br>
                        <article>
                            <ul>
                                <li>
                                    <strong>Types:</strong>
                                    <ul>
                                        <li><code>for</code>, <code>while</code>, and <code>do...while</code> loops for repeated execution of code.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>For...of Loop:</strong>
                                    <ul>
                                        <li>Iterates over iterable objects like arrays and strings.</li>
                                    </ul>
                                </li>
                            </ul>
                        </article>
                    </section>
                    <section>
                        <h3>15. Events</h3><br>
                        <article>
                            <ul>
                                <li>
                                    <strong>Event Handling:</strong>
                                    <ul>
                                        <li>Responding to user actions like clicks, keystrokes, and mouse movements.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Event Listeners:</strong>
                                    <ul>
                                        <li>Attach event listeners using methods like <code>addEventListener</code>.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Event Object:</strong>
                                    <ul>
                                        <li>Provides information about the event, like type and target element.</li>
                                    </ul>
                                </li>
                            </ul>
                        </article>
                    </section>
                    <section>
                        <h3>16. Objects and Userdefined Functions</h3><br>
                        <article>
                            <ul>
                                <li>
                                    <strong>JavaScript Objects:</strong>
                                    <ul>
                                        <li>Objects are collections of key-value pairs.</li>
                                        <li>They are created using object literals (<code>{}</code>) or with the <code>new Object()</code> constructor.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>User-defined Functions:</strong>
                                    <ul>
                                        <li>Functions in JavaScript can be created using the <code>function</code> keyword or arrow function syntax (<code>=&gt;</code>).</li>
                                        <li>Functions can be methods within objects or standalone.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Methods:</strong>
                                    <ul>
                                        <li>Functions defined inside objects are called methods.</li>
                                        <li>Access object properties using <code>this</code> keyword inside methods.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Constructor Functions:</strong>
                                    <ul>
                                        <li>Constructor functions are used to create object instances with specific properties and methods.</li>
                                        <li>The <code>new</code> keyword is used to create instances from constructor functions.</li>
                                    </ul>
                                </li>
                            </ul>
                        </article>
                    </section>
                    <section>
                        <h3>17. Validations Using Object Functions</h3><br>
                        <article>
                            <ul>
                                <li>
                                    <strong>Input Validation:</strong>
                                    <ul>
                                        <li>Validate user inputs to ensure data integrity and avoid security issues.</li>
                                        <li>Can be done using methods within objects or standalone functions.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Validation Functions:</strong>
                                    <ul>
                                        <li>Use functions or methods to validate data according to specified criteria (e.g., data type, format, range).</li>
                                        <li>Common Validation Functions:
                                            <ul>
                                                <li><code>isNaN</code>: Checks if a value is not a number.</li>
                                                <li><code>parseInt</code> and <code>parseFloat</code>: Convert strings to integers or floating-point numbers.</li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Example Validation Function:</strong>
                                    <pre><code>function validateInput(input) {
                        if (isNaN(input)) {
                            console.log("Input is not a number");
                        } else {
                            console.log("Valid input");
                        }
                    }</code></pre>
                                </li>
                                <li>
                                    <strong>Object Functions for Validation:</strong>
                                    <ul>
                                        <li>Define methods within objects to validate properties or data specific to the object.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Example of Validation in an Object:</strong>
                                    <pre><code>const user = {
                        name: "John",
                        age: 25,
                        validateAge: function() {
                            if (this.age < 18) {
                                console.log("User is underaged");
                            } else {
                                console.log("User is an adult");
                            }
                        }
                    };
                    
                    user.validateAge(); // Outputs: "User is an adult"</code></pre>
                                </li>
                            </ul>
                        </article>
                    </section>
                    <br>
                    <section>
                        <h3>18. Validations Using Regular Expressions</h3><br>
                        <article>
                            <ul>
                                <li>
                                    <strong>Regular Expressions:</strong>
                                    <ul>
                                        <li>Regular expressions (regex) are patterns used to match character combinations in strings.</li>
                                        <li>Useful for data validation, searching, and manipulating strings.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Syntax:</strong>
                                    <ul>
                                        <li>Patterns are defined using <code>/pattern/</code> syntax.</li>
                                        <li>Use flags for case-insensitive (<code>i</code>), global search (<code>g</code>), and multiline (<code>m</code>) matching.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Common Uses:</strong>
                                    <ul>
                                        <li>String Matching: Check if a string contains a pattern.</li>
                                        <li>Data Validation: Validate user inputs (e.g., email, phone numbers, etc.).</li>
                                        <li>String Manipulation: Replace or extract parts of a string.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Examples:</strong>
                                    <ul>
                                        <li>Email Validation:
                                            <pre><code>const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
                    const isValidEmail = emailPattern.test("example@domain.com");</code></pre>
                                        </li>
                                        <li>Phone Number Validation:
                                            <pre><code>const phonePattern = /^\d{10}$/; // Validates 10-digit phone numbers
                    const isValidPhone = phonePattern.test("1234567890");</code></pre>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </article>
                    </section>
                    <section>
                        <h3>19. JS Document Object Model</h3><br>
                        <article>
                            <ul>
                                <li>
                                    <strong>Definition:</strong>
                                    <ul>
                                        <li>The Document Object Model (DOM) is a programming interface for HTML and XML documents.</li>
                                        <li>It represents the document as a tree of nodes, allowing manipulation of the structure, style, and content.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Accessing DOM Elements:</strong>
                                    <ul>
                                        <li>Use methods like <code>document.getElementById()</code>, <code>document.querySelector()</code>, or <code>document.getElementsByClassName()</code> to access elements.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Manipulating DOM Elements:</strong>
                                    <ul>
                                        <li>Change content, attributes, and styles of elements using properties and methods (e.g., <code>innerHTML</code>, <code>style</code>).</li>
                                        <li>Create, modify, and remove elements from the DOM.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Event Handling:</strong>
                                    <ul>
                                        <li>Add event listeners to elements using <code>addEventListener()</code> to handle user interactions.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Example:</strong>
                                    <ul>
                                        <li>Changing an Element's Content:
                                            <pre><code>const element = document.getElementById("myElement");
                    element.innerHTML = "New content";</code></pre>
                                        </li>
                                        <li>Adding an Event Listener:
                                            <pre><code>const button = document.querySelector("button");
                    button.addEventListener("click", function() {
                        alert("Button clicked!");
                    });</code></pre>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </article>
                    </section>
                    <br>
                    <section>
                        <h3>20. Popovers</h3><br>
                        <article>
                            <ul>
                                <li>
                                    <strong>Definition:</strong>
                                    <ul>
                                        <li>Popovers are small overlays or tooltips that appear on the screen to provide additional information or actions.</li>
                                        <li>Often used to enhance user interaction and provide contextual information.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Implementation in JavaScript:</strong>
                                    <ul>
                                        <li>Popovers can be implemented using JavaScript and HTML/CSS for styling.</li>
                                        <li>Popular libraries like Bootstrap provide built-in support for creating and managing popovers.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Creating Popovers:</strong>
                                    <ul>
                                        <li>Define a trigger element (e.g., button) with a data attribute for the content.</li>
                                        <li>Use JavaScript to initialize and display the popover on the trigger event (e.g., click, hover).</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Example:</strong>
                                    <pre><code>&lt;button id="popoverButton" title="Popover Title" data-content="This is a popover."&gt;
                      Click me
                    &lt;/button&gt;
                    
                    &lt;script&gt;
                      document.addEventListener("DOMContentLoaded", function() {
                        const button = document.getElementById("popoverButton");
                        button.addEventListener("click", function() {
                          // Display the popover
                          alert(button.getAttribute("data-content"));
                        });
                      });
                    &lt;/script&gt;
                                    </code></pre>
                                </li>
                            </ul>
                        </article>
                    </section>
                    <section>
                        <h3>21. Windows</h3><br>
                        <article>
                            <ul>
                                <li>
                                    <strong>Definition:</strong>
                                    <ul>
                                        <li>In JavaScript, the global <code>window</code> object represents the browser's window.</li>
                                        <li>Provides access to global properties, functions, and browser operations.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Common Methods:</strong>
                                    <ul>
                                        <li><code>window.open()</code>: Opens a new browser window or tab.</li>
                                        <li><code>window.close()</code>: Closes the current browser window or tab.</li>
                                        <li><code>window.alert()</code>: Displays a pop-up alert with a message.</li>
                                        <li><code>window.prompt()</code>: Displays a prompt dialog for user input.</li>
                                        <li><code>window.confirm()</code>: Displays a confirmation dialog with OK and Cancel options.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Window Properties:</strong>
                                    <ul>
                                        <li><code>window.location</code>: Represents the URL of the current document and allows navigation.</li>
                                        <li><code>window.history</code>: Provides access to the browser's session history.</li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Example:</strong>
                                    <ul>
                                        <li>Opening a New Window:
                                            <pre><code>function openNewWindow() {
                      window.open("https://www.example.com", "_blank");
                    }</code></pre>
                                        </li>
                                        <li>Prompting User Input:
                                            <pre><code>function promptUser() {
                      const name = window.prompt("What is your name?");
                      if (name) {
                        alert("Hello, " + name + "!");
                      }
                    }</code></pre>
                                        </li>
                                    </ul>
                                </li>
                                <li>
                                    <strong>Best Practices:</strong>
                                    <ul>
                                        <li>Avoid excessive use of pop-ups as they can be disruptive to the user experience.</li>
                                        <li>Be mindful of modern browser security policies that may restrict window operations.</li>
                                    </ul>
                                </li>
                            </ul>
                        </article>
                    </section>
                    
                </div>

            </div>

            <!-- New section for notes -->
            <div class="notes-section">
                <h2>Save Your Useful Notes</h2>
                <div class="input-container">
                    <textarea id="notes" rows="10" cols="50" placeholder="Enter your notes here..."></textarea>
                </div>
                <br>
                <button id="save-btn">Save</button>
            </div>
            
        </div>
x
    </main>

    <footer>

        <div class="footer-wrapper" >
            <div class="footer-link-heading">Contact Us
            <div class="gfg-info">


                <a href="https://mail.google.com/mail/?view=cm&to=majorproject2024cse@gmail.com&su=&body=&bcc=" class="gfg-info-elems"><span class="material-symbols-outlined" style="color: var(--gfg-green); padding: 5px;">mail</span>majorproject2024cse@gmail.com</a>
                
            </div>
            
            <a href="about.html"><div class="footer-link-heading">About Us</div></a>
        </div>


            <div class="footer-strip">

            </div>

        </div>

    </footer>

</body>

</html>
